
#ifndef V_COMMIT_HASH
#define V_COMMIT_HASH "4e01bf4"
#endif


#ifndef V_CURRENT_COMMIT_HASH
#define V_CURRENT_COMMIT_HASH "61c1535"
#endif

typedef struct array array;
typedef struct KeyValue KeyValue;
typedef struct DenseArray DenseArray;
typedef struct map map;
typedef struct Option Option;
typedef struct SortedMap SortedMap;
typedef struct mapnode mapnode;
typedef struct string string;
typedef struct ustring ustring;
typedef struct RepIndex RepIndex;
typedef struct strings__Builder strings__Builder;
typedef struct strconv__ftoa__Dec32 strconv__ftoa__Dec32;
typedef union strconv__ftoa__Uf32 strconv__ftoa__Uf32;
typedef struct strconv__ftoa__Uint128 strconv__ftoa__Uint128;
typedef struct strconv__ftoa__Dec64 strconv__ftoa__Dec64;
typedef union strconv__ftoa__Uf64 strconv__ftoa__Uf64;
typedef union strconv__Float64u strconv__Float64u;
typedef struct strconv__PrepNumber strconv__PrepNumber;
typedef struct rand__Pcg32 rand__Pcg32;
typedef struct rand__Splitmix64 rand__Splitmix64;
typedef struct time__Time time__Time;
typedef enum {
	time__FormatTime_hhmm12,
	time__FormatTime_hhmm24,
	time__FormatTime_hhmmss12,
	time__FormatTime_hhmmss24,
	time__FormatTime_no_time,
} time__FormatTime;

typedef enum {
	time__FormatDate_ddmmyy,
	time__FormatDate_ddmmyyyy,
	time__FormatDate_mmddyy,
	time__FormatDate_mmddyyyy,
	time__FormatDate_mmmd,
	time__FormatDate_mmmdd,
	time__FormatDate_mmmddyyyy,
	time__FormatDate_no_date,
	time__FormatDate_yyyymmdd,
} time__FormatDate;

typedef enum {
	time__FormatDelimiter_dot,
	time__FormatDelimiter_hyphen,
	time__FormatDelimiter_slash,
	time__FormatDelimiter_space,
} time__FormatDelimiter;

typedef Option Option_int;
typedef Option Option_time__Time;
// Generated by the V compiler
#include <inttypes.h>


//================================== builtin types ================================*/

typedef int64_t i64;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t byte;
typedef uint32_t rune;
typedef float f32;
typedef double f64;
typedef unsigned char* byteptr;
typedef int* intptr;
typedef void* voidptr;
typedef char* charptr;
typedef struct array array;
typedef struct map map;
typedef array array_string;
typedef array array_int;
typedef array array_byte;
typedef array array_f32;
typedef array array_f64;
typedef array array_u16;
typedef array array_u32;
typedef array array_u64;
typedef map map_int;
typedef map map_string;
typedef byte array_fixed_byte_300 [300];
typedef byte array_fixed_byte_400 [400];
#ifndef bool
	typedef int bool;
	#define true 1
	#define false 0
#endif




// c_headers
#include <stdio.h>  // TODO remove all these includes, define all function signatures and types manually
#include <stdlib.h>
#include <float.h>

//#include "fns.h"
#include <signal.h>
#include <stdarg.h> // for va_list
#include <string.h> // memcpy

#if INTPTR_MAX == INT32_MAX
    #define TARGET_IS_32BIT 1
#elif INTPTR_MAX == INT64_MAX
    #define TARGET_IS_64BIT 1
#else
    #error "The environment is not 32 or 64-bit."
#endif

#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)
    #define TARGET_ORDER_IS_BIG
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_X64) || defined(_M_IX86)
    #define TARGET_ORDER_IS_LITTLE
#else
    #error "Unknown architecture endianness"
#endif

#ifndef _WIN32
#include <ctype.h>
#include <locale.h> // tolower
#include <sys/time.h>
#include <unistd.h> // sleep
extern char **environ;
#endif

#if defined(__CYGWIN__) && !defined(_WIN32)
#error Cygwin is not supported, please use MinGW or Visual Studio.
#endif


#ifdef __linux__
#include <sys/types.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __FreeBSD__
#include <sys/types.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __DragonFly__
#include <sys/types.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __OpenBSD__
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __NetBSD__
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __sun
#include <sys/types.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif


#define EMPTY_STRUCT_DECLARATION
#define EMPTY_STRUCT_INITIALIZATION 0
// Due to a tcc bug, the length of an array needs to be specified, but GCC crashes if it is...
#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[])
#define TCCSKIP(x) x

#ifdef __TINYC__
#undef EMPTY_STRUCT_DECLARATION
#undef EMPTY_STRUCT_INITIALIZATION
#define EMPTY_STRUCT_DECLARATION char _dummy
#define EMPTY_STRUCT_INITIALIZATION 0
#undef EMPTY_ARRAY_OF_ELEMS
#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])
#undef TCCSKIP
#define TCCSKIP(x)
#include <byteswap.h>
#endif

// for __offset_of
#ifndef __offsetof
#define __offsetof(s,memb) \
    ((size_t)((char *)&((s *)0)->memb - (char *)0))
#endif

#define OPTION_CAST(x) (x)

#ifndef V64_PRINTFORMAT
#ifdef PRIx64
#define V64_PRINTFORMAT "0x%"PRIx64
#elif defined(__WIN32__)
#define V64_PRINTFORMAT "0x%I64x"
#elif defined(__linux__) && defined(__LP64__)
#define V64_PRINTFORMAT "0x%lx"
#else
#define V64_PRINTFORMAT "0x%llx"
#endif
#endif



#ifdef _WIN32
#define WINVER 0x0600
#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif
#define _WIN32_WINNT 0x0600
#define WIN32_LEAN_AND_MEAN
#define _UNICODE
#define UNICODE
#include <windows.h>

#include <io.h> // _waccess
#include <direct.h> // _wgetcwd
//#include <WinSock2.h>
#ifdef _MSC_VER

// On MSVC these are the same (as long as /volatile:ms is passed)
#define _Atomic volatile

// MSVC cannot parse some things properly
#undef EMPTY_STRUCT_DECLARATION
#undef OPTION_CAST

#define EMPTY_STRUCT_DECLARATION int ____dummy_variable
#define OPTION_CAST(x)

#include <dbghelp.h>
#pragma comment(lib, "Dbghelp.lib")

extern wchar_t **_wenviron;

#endif

#else
#include <pthread.h>
#endif


//============================== HELPER C MACROS =============================*/
#define _PUSH(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push(arr, &tmp);}
#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many(arr, tmp.data, tmp.len);}
#define _IN(typ, val, arr) array_##typ##_contains(arr, val)
#define _IN_MAP(val, m) map_exists(m, val)
#define DEFAULT_EQUAL(a, b) (a == b)
#define DEFAULT_NOT_EQUAL(a, b) (a != b)
#define DEFAULT_LT(a, b) (a < b)
#define DEFAULT_LE(a, b) (a <= b)
#define DEFAULT_GT(a, b) (a > b)
#define DEFAULT_GE(a, b) (a >= b)

// NB: macro_fXX_eq and macro_fXX_ne are NOT used
// in the generated C code. They are here just for
// completeness/testing.

#define macro_f64_eq(a, b) (a == b)
#define macro_f64_ne(a, b) (a != b)
#define macro_f64_lt(a, b) (a <  b)
#define macro_f64_le(a, b) (a <= b)
#define macro_f64_gt(a, b) (a >  b)
#define macro_f64_ge(a, b) (a >= b)

#define macro_f32_eq(a, b) (a == b)
#define macro_f32_ne(a, b) (a != b)
#define macro_f32_lt(a, b) (a <  b)
#define macro_f32_le(a, b) (a <= b)
#define macro_f32_gt(a, b) (a >  b)
#define macro_f32_ge(a, b) (a >= b)

//================================== GLOBALS =================================*/
byte g_str_buf[1024];
int load_so(byteptr);
void reload_so();
void _vinit();
void _vcleanup();
#define sigaction_size sizeof(sigaction);
#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )

// ============== wyhash ==============
//Author: Wang Yi
#ifndef wyhash_version_gamma
#define wyhash_version_gamma
#define WYHASH_CONDOM 0
#include <stdint.h>
#include <string.h>
#if defined(_MSC_VER) && defined(_M_X64)
#include <intrin.h>
#pragma intrinsic(_umul128)
#endif

//const uint64_t _wyp0=0xa0761d6478bd642full, _wyp1=0xe7037ed1a0b428dbull;
#define _wyp0 ((uint64_t)0xa0761d6478bd642full)
#define _wyp1 ((uint64_t)0xe7037ed1a0b428dbull)


#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__) || defined(__TINYC__)
#define _likely_(x) __builtin_expect(x, 1)
#else
#define _likely_(x) (x)
#endif

#if defined(TARGET_ORDER_IS_LITTLE)
#define WYHASH_LITTLE_ENDIAN 1
#elif defined(TARGET_ORDER_IS_BIG)
#define WYHASH_LITTLE_ENDIAN 0
#endif

#if (WYHASH_LITTLE_ENDIAN)
  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}
  static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return v;}
#else
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}
  static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return __builtin_bswap32(v);}
#elif defined(_MSC_VER)
  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}
  static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return _byteswap_ulong(v);}
#elif defined(__TINYC__)
  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return bswap_64(v);}
  static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return bswap_32(v);}
#endif
#endif

static inline uint64_t _wyr3(const uint8_t *p, unsigned k) { return (((uint64_t)p[0]) << 16) | (((uint64_t)p[k >> 1]) << 8) | p[k - 1];}
static inline uint64_t _wyrotr(uint64_t v, unsigned k) { return (v >> k) | (v << (64 - k));}
static inline void _wymix128(uint64_t A, uint64_t B, uint64_t *C, uint64_t *D){
	A^=*C;	B^=*D;
#ifdef UNOFFICIAL_WYHASH_32BIT
	uint64_t hh=(A>>32)*(B>>32), hl=(A>>32)*(unsigned)B, lh=(unsigned)A*(B>>32), ll=(uint64_t)(unsigned)A*(unsigned)B;
	*C=_wyrotr(hl,32)^hh; *D=_wyrotr(lh,32)^ll;
#else
#ifdef __SIZEOF_INT128__
	__uint128_t r=A; r*=B; *C=(uint64_t)r; *D=(uint64_t)(r>>64);
#elif defined(_MSC_VER) && defined(_M_X64)
	A=_umul128(A,B,&B); *C=A; *D=B;
#else
	uint64_t ha=A>>32, hb=B>>32, la=(uint32_t)A, lb=(uint32_t)B, hi, lo;
	uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;
	lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;
	*C=lo;	*D=hi;
#endif
#endif
}
static inline uint64_t wyhash(const void *key, uint64_t len, uint64_t seed){
	const uint8_t *p=(const uint8_t *)key;
	uint64_t i=len, see1=seed; 
	start:
	if(_likely_(i<=16)){
	#ifndef	WYHASH_CONDOM
		uint64_t shift=(i<8)*((8-i)<<3);
		//WARNING: intended reading outside buffer, trading for speed.
		_wymix128((_wyr8(p)<<shift)^_wyp0,(_wyr8(p+i-8)>>shift)^_wyp1, &seed, &see1);
	#else
		if(_likely_(i<=8)){
			if(_likely_(i>=4))	_wymix128(_wyr4(p)^_wyp0,_wyr4(p+i-4)^_wyp1, &seed, &see1);
			else if (_likely_(i))	_wymix128(_wyr3(p,i)^_wyp0,_wyp1, &seed, &see1);
			else	_wymix128(_wyp0,_wyp1, &seed, &see1);
		} 
  		else	_wymix128(_wyr8(p)^_wyp0,_wyr8(p+i-8)^_wyp1, &seed, &see1);
	#endif
		_wymix128(len,_wyp0, &seed, &see1);
		return	seed^see1;
	}
	_wymix128(_wyr8(p)^_wyp0,_wyr8(p+8)^_wyp1, &seed, &see1);
	i-=16;	p+=16;	goto start;
}
static inline uint64_t wyhash64(uint64_t A, uint64_t B){
	_wymix128(_wyp0,_wyp1,&A,&B);
	_wymix128(0,0,&A,&B);
	return	A^B;
}
static inline uint64_t wyrand(uint64_t *seed){ 
	*seed+=_wyp0;
	uint64_t	a=0, b=0;
	_wymix128(*seed,*seed^_wyp1,&a,&b);
	return	a^b;
}
static inline double wy2u01(uint64_t r) { 
	const double _wynorm=1.0/(1ull<<52); 
	return (r>>12)*_wynorm;
}
static inline double wy2gau(uint64_t r) { 
	const double _wynorm=1.0/(1ull<<20); 
	return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;
}
#endif



string _STR(const char*, ...);


string _STR_TMP(const char*, ...);

struct string {
	byteptr str;
	int len;
};

struct array {
	voidptr data;
	int len;
	int cap;
	int element_size;
};

struct KeyValue {
	string key;
	voidptr value;
};

struct DenseArray {
	u32 cap;
	u32 size;
	u32 deletes;
	KeyValue* data;
};

struct map {
	int value_bytes;
	u32 cap;
	byte cached_hashbits;
	byte shift;
	DenseArray key_values;
	u32* metas;
	u32 extra_metas;
	int size;
};

struct Option {
	array_fixed_byte_400 data;
	string v_error;
	int ecode;
	bool ok;
	bool is_none;
};

typedef map map_string_string;
typedef map map_string_int;
typedef map_string_string map_string;
typedef map_string_int map_int;
typedef array array_string;
typedef array array_int;
typedef array array_bool;
typedef array array_byte;
typedef array array_char;
typedef array array_voidptr;
typedef array array_RepIndex;
typedef voidptr time__time_t;
typedef array array_u32;
typedef array array_u64;
typedef array array_strconv__ftoa__Uint128;
// builtin types:
//------------------ #endbuiltin
typedef string array_fixed_string_11 [11];
typedef byte array_fixed_byte_400 [400];
struct SortedMap {
	int value_bytes;
	mapnode* root;
	int size;
};

typedef voidptr array_fixed_voidptr_11 [11];
struct ustring {
	string s;
	array_int runes;
	int len;
};

struct RepIndex {
	int idx;
	int val_idx;
};

struct strings__Builder {
	array_byte buf;
	int len;
	int initial_size;
};

struct strconv__ftoa__Dec32 {
	u32 m;
	int e;
};

union strconv__ftoa__Uf32 {
	f32 f;
	u32 u;
};

struct strconv__ftoa__Uint128 {
	u64 lo;
	u64 hi;
};

struct strconv__ftoa__Dec64 {
	u64 m;
	int e;
};

union strconv__ftoa__Uf64 {
	f64 f;
	u64 u;
};

union strconv__Float64u {
	f64 f;
	u64 u;
};

struct strconv__PrepNumber {
	bool negative;
	int exponent;
	u64 mantissa;
};

struct rand__Pcg32 {
	u64 state;
	u64 inc;
};

struct rand__Splitmix64 {
	u64 state;
};

struct time__Time {
	int year;
	int month;
	int day;
	int hour;
	int minute;
	int second;
	u64 v_unix;
};

typedef byteptr array_fixed_byteptr_100 [100];
typedef byte array_fixed_byte_1000 [1000];
typedef byte array_fixed_byte_26 [26];
struct mapnode {
	array_fixed_string_11 keys;
	array_fixed_voidptr_11 values;
	voidptr* children;
	int size;
};

// multi return structs
typedef struct {
	u32 arg0;
	u32 arg1;
} multi_return_u32_u32;

typedef struct {
	strconv__ftoa__Dec32 arg0;
	bool arg1;
} multi_return_strconv__ftoa__Dec32_bool;

typedef struct {
	strconv__ftoa__Dec64 arg0;
	bool arg1;
} multi_return_strconv__ftoa__Dec64_bool;

typedef struct {
	u32 arg0;
	u32 arg1;
	u32 arg2;
} multi_return_u32_u32_u32;

typedef struct {
	int arg0;
	strconv__PrepNumber arg1;
} multi_return_int_strconv__PrepNumber;

typedef struct {
	int arg0;
	int arg1;
	int arg2;
} multi_return_int_int_int;

typedef struct {
	u64 arg0;
	u64 arg1;
} multi_return_u64_u64;

// end of definitions #endif
array new_array(int mylen, int cap, int elm_size);
array make(int len, int cap, int elm_size);
array new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array);
array new_array_from_c_array_no_alloc(int len, int cap, int elm_size, voidptr c_array);
void array_ensure_cap(array* a, int required);
array array_repeat(array a, int count);
void array_sort_with_compare(array* a, voidptr compare);
void array_insert(array* a, int i, voidptr val);
void array_prepend(array* a, voidptr val);
void array_delete(array* a, int i);
void array_clear(array* a);
void array_trim(array* a, int index);
voidptr array_get(array a, int i);
voidptr array_first(array a);
voidptr array_last(array a);
array array_slice(array a, int start, int _end);
array array_slice2(array a, int start, int _end, bool end_max);
array array_clone(array* a);
array array_slice_clone(array* a, int start, int _end);
void array_set(array* a, int i, voidptr val);
void array_push(array* a, voidptr val);
void array_push_many(array* a3, voidptr val, int size);
array array_reverse(array a);
void array_free(array a);
string array_string_str(array_string a);
string array_int_str(array_int a);
string array_bool_str(array_bool a);
string array_byte_hex(array_byte b);
int copy(array_byte dst, array_byte src);
int compare_ints(int* a, int* b);
void array_int_sort(array_int* a);
int array_string_index(array_string a, string v);
int array_int_index(array_int a, int v);
int array_byte_index(array_byte a, byte v);
int array_char_index(array_char a, char v);
int array_int_reduce(array_int a, int (*iter)(int accum, int curr), int accum_start);
bool array_string_eq(array_string a1, array_string a2);
int compare_i64(i64* a, i64* b);
int compare_f64(f64* a, f64* b);
int compare_f32(f32* a, f32* b);
array_voidptr array_pointers(array a);
byteptr g_m2_buf; // global
byteptr g_m2_ptr; // global
void v_exit(int code);
bool isnil(voidptr v);
void print_backtrace_skipping_top_frames(int skipframes);
void print_backtrace();
void panic_debug(int line_no, string file, string mod, string fn_name, string s);
void v_panic(string s);
void eprintln(string s);
void eprint(string s);
void print(string s);
i64 total_m; // global
int nr_mallocs; // global
void looo();
byteptr v_malloc(int n);
byteptr v_calloc(int n);
byteptr vcalloc(int n);
void v_free(voidptr ptr);
voidptr memdup(voidptr src, int sz);
void v_ptr_free(voidptr ptr);
int is_atty(int fd);
void builtin_init();
void println(string s);
bool print_backtrace_skipping_top_frames_msvc(int skipframes);
bool print_backtrace_skipping_top_frames_mingw(int skipframes);
bool print_backtrace_skipping_top_frames_nix(int xskipframes);
bool print_backtrace_skipping_top_frames_mac(int skipframes);
bool print_backtrace_skipping_top_frames_freebsd(int skipframes);
bool print_backtrace_skipping_top_frames_linux(int skipframes);
int backtrace(voidptr a, int b);
byteptr* backtrace_symbols(voidptr, int);
void backtrace_symbols_fd(voidptr, int, int);
int proc_pidpath(int, voidptr, int);
#include <float.h>
string f64_str(f64 d);
string f64_strsci(f64 x, int digit_num);
string f64_strlong(f64 x);
string f32_str(f32 d);
string f32_strsci(f32 x, int digit_num);
string f32_strlong(f32 x);
f32 f32_abs(f32 a);
f64 f64_abs(f64 a);
bool f64_eq(f64 a, f64 b);
bool f32_eq(f32 a, f32 b);
bool f64_eqbit(f64 a, f64 b);
bool f32_eqbit(f32 a, f32 b);
bool f64_ne(f64 a, f64 b);
bool f32_ne(f32 a, f32 b);
bool f64_nebit(f64 a, f64 b);
bool f32_nebit(f32 a, f32 b);
bool f64_lt(f64 a, f64 b);
bool f32_lt(f32 a, f32 b);
bool f64_ltbit(f64 a, f64 b);
bool f32_ltbit(f32 a, f32 b);
bool f64_le(f64 a, f64 b);
bool f32_le(f32 a, f32 b);
bool f64_lebit(f64 a, f64 b);
bool f32_lebit(f32 a, f32 b);
bool f64_gt(f64 a, f64 b);
bool f32_gt(f32 a, f32 b);
bool f64_gtbit(f64 a, f64 b);
bool f32_gtbit(f32 a, f32 b);
bool f64_ge(f64 a, f64 b);
bool f32_ge(f32 a, f32 b);
bool f64_gebit(f64 a, f64 b);
bool f32_gebit(f32 a, f32 b);
string ptr_str(voidptr ptr);
string _const_digit_pairs; // a string literal, inited later
string int_str_l(int nn, int max);
string i8_str(i8 n);
string i16_str(i16 n);
string u16_str(u16 n);
string int_str(int n);
string u32_str(u32 nn);
string i64_str(i64 nn);
string u64_str(u64 nn);
string bool_str(bool b);
string byte_hex(byte nn);
string i8_hex(i8 nn);
string u16_hex(u16 nn);
string i16_hex(i16 nn);
string u32_hex(u32 nn);
string int_hex(int nn);
string u64_hex(u64 nn);
string i64_hex(i64 nn);
bool array_byte_contains(array_byte a, byte val);
string rune_str(rune c);
string byte_str(byte c);
bool byte_is_capital(byte c);
array_byte array_byte_clone(array_byte b);
#define _const_hashbits 24
#define _const_max_cached_hashbits 16
#define _const_init_log_capicity 5
int _const_init_capicity; // inited later
f64 _const_max_load_factor; // inited later
int _const_init_cap; // inited later
#define _const_extra_metas_inc 4
u32 _const_hash_mask; // inited later
u32 _const_probe_inc; // inited later
DenseArray new_dense_array();
u32 DenseArray_push(DenseArray* d, KeyValue kv);
void DenseArray_zeros_to_end(DenseArray* d);
map new_map(int n, int value_bytes);
map new_map_init(int n, int value_bytes, string* keys, voidptr values);
multi_return_u32_u32 map_key_to_index(map m, string key);
multi_return_u32_u32 map_meta_less(map m, u32 _index, u32 _metas);
void map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi);
void map_set(map* m, string key, voidptr value);
void map_expand(map* m);
void map_rehash(map* m);
void map_cached_rehash(map* m, u32 old_cap);
voidptr map_get3(map m, string key, voidptr zero);
bool map_exists(map m, string key);
void map_delete(map* m, string key);
array_string map_keys(map* m);
void map_free(map m);
void map_print(map m);
string map_string_str(map_string m);
Option opt_ok(voidptr data, int size);
Option opt_none();
Option v_error(string s);
Option error_with_code(string s, int code);
#define _const_degree 6
int _const_mid_index; // inited later
int _const_max_size; // inited later
int _const_children_bytes; // inited later
SortedMap new_sorted_map(int n, int value_bytes);
SortedMap new_sorted_map_init(int n, int value_bytes, string* keys, voidptr values);
mapnode* new_node();
void SortedMap_set(SortedMap* m, string key, voidptr value);
void mapnode_split_child(mapnode* n, int child_index, mapnode* y);
bool SortedMap_get(SortedMap m, string key, voidptr out);
bool SortedMap_exists(SortedMap m, string key);
int mapnode_find_key(mapnode* n, string k);
bool mapnode_remove_key(mapnode* n, string k);
void mapnode_remove_from_leaf(mapnode* n, int idx);
void mapnode_remove_from_non_leaf(mapnode* n, int idx);
void mapnode_fill(mapnode* n, int idx);
void mapnode_borrow_from_prev(mapnode* n, int idx);
void mapnode_borrow_from_next(mapnode* n, int idx);
void mapnode_merge(mapnode* n, int idx);
void SortedMap_delete(SortedMap* m, string key);
int mapnode_subkeys(mapnode* n, array_string* keys, int at);
array_string SortedMap_keys(SortedMap* m);
void mapnode_free(mapnode* n);
void SortedMap_free(SortedMap* m);
void SortedMap_print(SortedMap m);
int vstrlen(byteptr s);
string tos(byteptr s, int len);
string tos_clone(byteptr s);
string tos2(byteptr s);
string tos3(charptr s);
string string_clone(string a);
string cstring_to_vstring(byteptr cstr);
string string_replace_once(string s, string rep, string with);
string string_replace(string s, string rep, string with);
int compare_rep_index(RepIndex* a, RepIndex* b);
void array_RepIndex_sort(array_RepIndex* a);
string string_replace_each(string s, array_string vals);
bool string_bool(string s);
int string_int(string s);
i64 string_i64(string s);
i8 string_i8(string s);
i16 string_i16(string s);
f32 string_f32(string s);
f64 string_f64(string s);
u16 string_u16(string s);
u32 string_u32(string s);
u64 string_u64(string s);
bool string_eq(string s, string a);
bool string_ne(string s, string a);
bool string_lt(string s, string a);
bool string_le(string s, string a);
bool string_gt(string s, string a);
bool string_ge(string s, string a);
string string_add(string s, string a);
array_string string_split(string s, string delim);
array_string string_split_nth(string s, string delim, int nth);
array_string string_split_into_lines(string s);
string string_left(string s, int n);
string string_right(string s, int n);
string string_substr2(string s, int start, int _end, bool end_max);
string string_substr(string s, int start, int end);
int string_index_old(string s, string p);
Option_int string_index(string s, string p);
int string_index_kmp(string s, string p);
int string_index_any(string s, string chars);
Option_int string_last_index(string s, string p);
int string_index_after(string s, string p, int start);
int string_index_byte(string s, byte c);
int string_last_index_byte(string s, byte c);
int string_count(string s, string substr);
bool string_contains(string s, string p);
bool string_starts_with(string s, string p);
bool string_ends_with(string s, string p);
string string_to_lower(string s);
string string_to_upper(string s);
string string_capitalize(string s);
string string_title(string s);
string string_find_between(string s, string start, string end);
bool array_string_contains(array_string ar, string val);
bool array_int_contains(array_int ar, int val);
bool byte_is_space(byte c);
string string_trim_space(string s);
string string_trim(string s, string cutset);
string string_trim_left(string s, string cutset);
string string_trim_right(string s, string cutset);
int compare_strings(string* a, string* b);
int compare_strings_by_len(string* a, string* b);
int compare_lower_strings(string* a, string* b);
void array_string_sort(array_string* s);
void array_string_sort_ignore_case(array_string* s);
void array_string_sort_by_len(array_string* s);
string ustring_str(ustring s);
ustring string_ustring(string s);
array_int g_ustring_runes; // global
ustring string_ustring_tmp(string s);
bool ustring_eq(ustring u, ustring a);
bool ustring_ne(ustring u, ustring a);
bool ustring_lt(ustring u, ustring a);
bool ustring_le(ustring u, ustring a);
bool ustring_gt(ustring u, ustring a);
bool ustring_ge(ustring u, ustring a);
ustring ustring_add(ustring u, ustring a);
int ustring_index_after(ustring u, ustring p, int start);
int ustring_count(ustring u, ustring substr);
string ustring_substr(ustring u, int _start, int _end);
string ustring_left(ustring u, int pos);
string ustring_right(ustring u, int pos);
byte string_at(string s, int idx);
string ustring_at(ustring u, int idx);
void ustring_free(ustring u);
bool byte_is_digit(byte c);
bool byte_is_hex_digit(byte c);
bool byte_is_oct_digit(byte c);
bool byte_is_bin_digit(byte c);
bool byte_is_letter(byte c);
void string_free(string s);
string string_all_before(string s, string dot);
string string_all_before_last(string s, string dot);
string string_all_after(string s, string dot);
string string_after(string s, string dot);
string array_string_join(array_string a, string del);
string array_string_join_lines(array_string s);
string string_reverse(string s);
string string_limit(string s, int max);
bool byte_is_white(byte c);
int string_hash(string s);
array_byte string_bytes(string s);
string string_repeat(string s, int count);
string string_strip_margin(string s);
string string_strip_margin_custom(string s, byte del);
int utf8_char_len(byte b);
string utf32_to_str(u32 code);
string utf32_to_str_no_malloc(u32 code, voidptr buf);
int string_utf32_code(string _rune);
#define _const_CP_UTF8 65001
u16* string_to_wide(string _str);
string string_from_wide(u16* _wstr);
string string_from_wide2(u16* _wstr, int len);
int utf8_len(byte c);
int utf8_getchar();
string* generate_strings(int len, int amount);
bool fast_string_eq(string a, string b);
bool fast_string_eq2(string a, string b);
strings__Builder strings__new_builder(int initial_size);
void strings__Builder_write_bytes(strings__Builder* b, byteptr bytes, int howmany);
void strings__Builder_write_b(strings__Builder* b, byte data);
void strings__Builder_write(strings__Builder* b, string s);
void strings__Builder_go_back(strings__Builder* b, int n);
void strings__Builder_writeln(strings__Builder* b, string s);
string strings__Builder_last_n(strings__Builder* b, int n);
string strings__Builder_after(strings__Builder* b, int n);
string strings__Builder_str(strings__Builder* b);
void strings__Builder_free(strings__Builder* b);
int strings__levenshtein_distance(string a, string b);
f32 strings__levenshtein_distance_percentage(string a, string b);
f32 strings__dice_coefficient(string s1, string s2);
string strings__repeat(byte c, int n);
string strings__repeat_string(string s, int n);
array_u32 _const_strconv__ftoa__ten_pow_table_32; // inited later
u32 _const_strconv__ftoa__mantbits32; // inited later
u32 _const_strconv__ftoa__expbits32; // inited later
u32 _const_strconv__ftoa__bias32; // inited later
#define _const_strconv__ftoa__maxexp32 255
string strconv__ftoa__Dec32_get_string_32(strconv__ftoa__Dec32 d, bool neg, int i_n_digit);
multi_return_strconv__ftoa__Dec32_bool strconv__ftoa__f32_to_decimal_exact_int(u32 i_mant, u32 exp);
strconv__ftoa__Dec32 strconv__ftoa__f32_to_decimal(u32 mant, u32 exp);
string strconv__ftoa__f32_to_str(f32 f, int n_digit);
array_u64 _const_strconv__ftoa__ten_pow_table_64; // inited later
u32 _const_strconv__ftoa__mantbits64; // inited later
u32 _const_strconv__ftoa__expbits64; // inited later
u32 _const_strconv__ftoa__bias64; // inited later
#define _const_strconv__ftoa__maxexp64 2047
string strconv__ftoa__Dec64_get_string_64(strconv__ftoa__Dec64 d, bool neg, int i_n_digit);
multi_return_strconv__ftoa__Dec64_bool strconv__ftoa__f64_to_decimal_exact_int(u64 i_mant, u64 exp);
strconv__ftoa__Dec64 strconv__ftoa__f64_to_decimal(u64 mant, u64 exp);
string strconv__ftoa__f64_to_str(f64 f, int n_digit);
string strconv__ftoa__ftoa_64(f64 f);
string strconv__ftoa__ftoa_long_64(f64 f);
string strconv__ftoa__ftoa_32(f32 f);
string strconv__ftoa__ftoa_long_32(f32 f);
#define _const_strconv__ftoa__pow5_num_bits_32 61
#define _const_strconv__ftoa__pow5_inv_num_bits_32 59
#define _const_strconv__ftoa__pow5_num_bits_64 121
#define _const_strconv__ftoa__pow5_inv_num_bits_64 122
array_u64 _const_strconv__ftoa__powers_of_10; // inited later
array_u64 _const_strconv__ftoa__pow5_split_32; // inited later
array_u64 _const_strconv__ftoa__pow5_inv_split_32; // inited later
array_strconv__ftoa__Uint128 _const_strconv__ftoa__pow5_split_64; // inited later
array_strconv__ftoa__Uint128 _const_strconv__ftoa__pow5_inv_split_64; // inited later
void strconv__ftoa__assert1(bool t, string msg);
int strconv__ftoa__bool_to_int(bool b);
u32 strconv__ftoa__bool_to_u32(bool b);
u64 strconv__ftoa__bool_to_u64(bool b);
string strconv__ftoa__get_string_special(bool neg, bool expZero, bool mantZero);
int strconv__ftoa__decimal_len_32(u32 u);
u32 strconv__ftoa__mul_shift_32(u32 m, u64 mul, int ishift);
u32 strconv__ftoa__mul_pow5_invdiv_pow2(u32 m, u32 q, int j);
u32 strconv__ftoa__mul_pow5_div_pow2(u32 m, u32 i, int j);
u32 strconv__ftoa__pow5_factor_32(u32 i_v);
bool strconv__ftoa__multiple_of_power_of_five_32(u32 v, u32 p);
bool strconv__ftoa__multiple_of_power_of_two_32(u32 v, u32 p);
u32 strconv__ftoa__log10_pow2(int e);
u32 strconv__ftoa__log10_pow5(int e);
int strconv__ftoa__pow5_bits(int e);
int strconv__ftoa__decimal_len_64(u64 u);
u64 strconv__ftoa__shift_right_128(strconv__ftoa__Uint128 v, int shift);
u64 strconv__ftoa__mul_shift_64(u64 m, strconv__ftoa__Uint128 mul, int shift);
u32 strconv__ftoa__pow5_factor_64(u64 v_i);
bool strconv__ftoa__multiple_of_power_of_five_64(u64 v, u32 p);
bool strconv__ftoa__multiple_of_power_of_two_64(u64 v, u32 p);
string strconv__ftoa__f32_to_str_l(f64 f);
string strconv__ftoa__f64_to_str_l(f64 f);
u64 hash__wyhash__rand_u64(u64* seed);
u64 _const_hash__wyhash__wyp0; // inited later
u64 _const_hash__wyhash__wyp1; // inited later
u64 _const_hash__wyhash__wyp2; // inited later
u64 _const_hash__wyhash__wyp3; // inited later
u64 _const_hash__wyhash__wyp4; // inited later
u64 hash__wyhash__wyhash_c(byteptr key, u64 len, u64 seed);
u64 hash__wyhash__sum64_string(string key, u64 seed);
u64 hash__wyhash__sum64(array_byte key, u64 seed);
u64 hash__wyhash__wyhash64(byteptr key, u64 len, u64 seed_);
u64 hash__wyhash__wyrotr(u64 v, u32 k);
u64 hash__wyhash__wymum(u64 a, u64 b);
u64 hash__wyhash__wyr3(byteptr p, u64 k);
u64 hash__wyhash__wyr4(byteptr p);
u64 hash__wyhash__wyr8(byteptr p);
multi_return_u32_u32_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0);
multi_return_u32_u32_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0);
multi_return_u32_u32_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0);
multi_return_u32_u32_u32 strconv__sub96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0);
#define _const_strconv__DIGITS 18
u64 _const_strconv__DOUBLE_PLUS_ZERO; // inited later
u64 _const_strconv__DOUBLE_MINUS_ZERO; // inited later
u64 _const_strconv__DOUBLE_PLUS_INFINITY; // inited later
u64 _const_strconv__DOUBLE_MINUS_INFINITY; // inited later
#define _const_strconv__fsm_a 0
#define _const_strconv__fsm_b 1
#define _const_strconv__fsm_c 2
#define _const_strconv__fsm_d 3
#define _const_strconv__fsm_e 4
#define _const_strconv__fsm_f 5
#define _const_strconv__fsm_g 6
#define _const_strconv__fsm_h 7
#define _const_strconv__fsm_i 8
#define _const_strconv__FSM_STOP 9
#define _const_strconv__parser_ok 0
#define _const_strconv__parser_pzero 1
#define _const_strconv__parser_mzero 2
#define _const_strconv__parser_pinf 3
#define _const_strconv__parser_minf 4
#define _const_strconv__DPOINT '.'
#define _const_strconv__PLUS '+'
#define _const_strconv__MINUS '-'
#define _const_strconv__ZERO '0'
#define _const_strconv__NINE '9'
u32 _const_strconv__TEN; // inited later
bool strconv__is_digit(byte x);
bool strconv__is_space(byte x);
bool strconv__is_exp(byte x);
multi_return_int_strconv__PrepNumber strconv__parser(string s);
u64 strconv__converter(strconv__PrepNumber* pn);
f64 strconv__atof64(string s);
#define _const_strconv__int_size 32
u64 _const_strconv__max_u64; // inited later
byte strconv__byte_to_lower(byte c);
u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
u64 strconv__parse_uint(string s, int _base, int _bit_size);
i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
i64 strconv__parse_int(string _s, int base, int _bit_size);
int strconv__atoi(string s);
bool strconv__underscore_ok(string s);
rand__Pcg32 rand__new_pcg32(u64 initstate, u64 initseq);
u32 rand__Pcg32_next(rand__Pcg32* rng);
u32 rand__Pcg32_bounded_next(rand__Pcg32* rng, u32 bound);
void rand__seed(int s);
int rand__next(int max);
int rand__rand_r(int* seed);
rand__Splitmix64 rand__new_splitmix64(u64 seed);
u64 rand__Splitmix64_next(rand__Splitmix64* rng);
u64 rand__Splitmix64_bounded_next(rand__Splitmix64* rng, u64 bound);
string time__Time_format(time__Time t);
string time__Time_format_ss(time__Time t);
string time__Time_hhmm(time__Time t);
string time__Time_hhmmss(time__Time t);
string time__Time_hhmm12(time__Time t);
string time__Time_ymmdd(time__Time t);
string time__Time_ddmmy(time__Time t);
string time__Time_md(time__Time t);
string time__Time_clean(time__Time t);
string time__Time_clean12(time__Time t);
string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time);
string time__FormatTime_str(time__FormatTime it) {
	switch(it) {
		case time__FormatTime_hhmm12: return tos3("hhmm12");
		case time__FormatTime_hhmm24: return tos3("hhmm24");
		case time__FormatTime_hhmmss12: return tos3("hhmmss12");
		case time__FormatTime_hhmmss24: return tos3("hhmmss24");
		case time__FormatTime_no_time: return tos3("no_time");
		default: return tos3("unknown enum value"); } }
string time__Time_get_fmt_date_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatDate fmt_date);
string time__FormatDate_str(time__FormatDate it) {
	switch(it) {
		case time__FormatDate_ddmmyy: return tos3("ddmmyy");
		case time__FormatDate_ddmmyyyy: return tos3("ddmmyyyy");
		case time__FormatDate_mmddyy: return tos3("mmddyy");
		case time__FormatDate_mmddyyyy: return tos3("mmddyyyy");
		case time__FormatDate_mmmd: return tos3("mmmd");
		case time__FormatDate_mmmdd: return tos3("mmmdd");
		case time__FormatDate_mmmddyyyy: return tos3("mmmddyyyy");
		case time__FormatDate_no_date: return tos3("no_date");
		case time__FormatDate_yyyymmdd: return tos3("yyyymmdd");
		default: return tos3("unknown enum value"); } }
string time__FormatDelimiter_str(time__FormatDelimiter it) {
	switch(it) {
		case time__FormatDelimiter_dot: return tos3("dot");
		case time__FormatDelimiter_hyphen: return tos3("hyphen");
		case time__FormatDelimiter_slash: return tos3("slash");
		case time__FormatDelimiter_space: return tos3("space");
		default: return tos3("unknown enum value"); } }
string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatTime fmt_time, time__FormatDate fmt_date);
Option_time__Time time__parse(string s);
Option_time__Time time__parse_rfc2822(string s);
#include <time.h>
string _const_time__days_string; // a string literal, inited later
array_int _const_time__month_days; // inited later
string _const_time__months_string; // a string literal, inited later
i64 _const_time__absolute_zero_year; // inited later
#define _const_time__seconds_per_minute 60
int _const_time__seconds_per_hour; // inited later
int _const_time__seconds_per_day; // inited later
int _const_time__seconds_per_week; // inited later
int _const_time__days_per_400_years; // inited later
int _const_time__days_per_100_years; // inited later
int _const_time__days_per_4_years; // inited later
array_int _const_time__days_before; // inited later
time__Time time__now();
string time__Time_smonth(time__Time t);
time__Time time__new_time(time__Time t);
int time__Time_unix_time(time__Time t);
time__Time time__Time_add_seconds(time__Time t, int seconds);
time__Time time__Time_add_days(time__Time t, int days);
int time__since(time__Time t);
string time__Time_relative(time__Time t);
int time__day_of_week(int y, int m, int d);
int time__Time_day_of_week(time__Time t);
string time__Time_weekday_str(time__Time t);
i64 time__ticks();
void time__sleep(int seconds);
void time__sleep_ms(int milliseconds);
void time__usleep(int microseconds);
bool time__is_leap_year(int year);
Option_int time__days_in_month(int month, int year);
string time__Time_str(time__Time t);
time__Time time__convert_ctime(struct tm t);
int time__make_unix_time(struct tm t);
time__Time time__unix(int abs);
multi_return_int_int_int time__calculate_date_from_offset(int day_offset_);
multi_return_int_int_int time__calculate_time_from_offset(int second_offset_);
u32 _const_math__bits__de_bruijn32; // inited later
array_byte _const_math__bits__de_bruijn32tab; // inited later
u64 _const_math__bits__de_bruijn64; // inited later
array_byte _const_math__bits__de_bruijn64tab; // inited later
u64 _const_math__bits__m0; // inited later
u64 _const_math__bits__m1; // inited later
u64 _const_math__bits__m2; // inited later
u64 _const_math__bits__m3; // inited later
u64 _const_math__bits__m4; // inited later
u32 _const_math__bits__max_u32; // inited later
u64 _const_math__bits__max_u64; // inited later
int math__bits__leading_zeros_8(byte x);
int math__bits__leading_zeros_16(u16 x);
int math__bits__leading_zeros_32(u32 x);
int math__bits__leading_zeros_64(u64 x);
int math__bits__trailing_zeros_8(byte x);
int math__bits__trailing_zeros_16(u16 x);
int math__bits__trailing_zeros_32(u32 x);
int math__bits__trailing_zeros_64(u64 x);
int math__bits__ones_count_8(byte x);
int math__bits__ones_count_16(u16 x);
int math__bits__ones_count_32(u32 x);
int math__bits__ones_count_64(u64 x);
byte math__bits__rotate_left_8(byte x, int k);
u16 math__bits__rotate_left_16(u16 x, int k);
u32 math__bits__rotate_left_32(u32 x, int k);
u64 math__bits__rotate_left_64(u64 x, int k);
byte math__bits__reverse_8(byte x);
u16 math__bits__reverse_16(u16 x);
u32 math__bits__reverse_32(u32 x);
u64 math__bits__reverse_64(u64 x);
u16 math__bits__reverse_bytes_16(u16 x);
u32 math__bits__reverse_bytes_32(u32 x);
u64 math__bits__reverse_bytes_64(u64 x);
int math__bits__len_8(byte x);
int math__bits__len_16(u16 x);
int math__bits__len_32(u32 x);
int math__bits__len_64(u64 x);
multi_return_u32_u32 math__bits__add_32(u32 x, u32 y, u32 carry);
multi_return_u64_u64 math__bits__add_64(u64 x, u64 y, u64 carry);
multi_return_u32_u32 math__bits__sub_32(u32 x, u32 y, u32 borrow);
multi_return_u64_u64 math__bits__sub_64(u64 x, u64 y, u64 borrow);
u64 _const_math__bits__two32; // inited later
u64 _const_math__bits__mask32; // inited later
string _const_math__bits__overflow_error; // a string literal, inited later
string _const_math__bits__divide_error; // a string literal, inited later
multi_return_u32_u32 math__bits__mul_32(u32 x, u32 y);
multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y);
multi_return_u32_u32 math__bits__div_32(u32 hi, u32 lo, u32 y);
multi_return_u64_u64 math__bits__div_64(u64 hi, u64 lo, u64 y1);
u32 math__bits__rem_32(u32 hi, u32 lo, u32 y);
u64 math__bits__rem_64(u64 hi, u64 lo, u64 y);
array_byte _const_math__bits__ntz_8_tab; // inited later
array_byte _const_math__bits__pop_8_tab; // inited later
array_byte _const_math__bits__rev_8_tab; // inited later
array_byte _const_math__bits__len_8_tab; // inited later

// >> string literal consts
void vinit_string_literals(){
	_const_digit_pairs = tos3("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	_const_time__days_string = tos3("MonTueWedThuFriSatSun");
	_const_time__months_string = tos3("JanFebMarAprMayJunJulAugSepOctNovDec");
	_const_math__bits__overflow_error = tos3("Overflow Error");
	_const_math__bits__divide_error = tos3("Divide Error");
}
// << string literal consts


// >> typeof() support for sum types
// << typeof() support for sum types


string _STR(const char *fmt, ...) {
	va_list argptr;
	va_start(argptr, fmt);
	size_t len = vsnprintf(0, 0, fmt, argptr) + 1;
	va_end(argptr);
	byte* buf = malloc(len);
	va_start(argptr, fmt);
	vsprintf((char *)buf, fmt, argptr);
	va_end(argptr);
#ifdef DEBUG_ALLOC
	puts("_STR:");
	puts(buf);
#endif
	return tos2(buf);
}

string _STR_TMP(const char *fmt, ...) {
	va_list argptr;
	va_start(argptr, fmt);
	//size_t len = vsnprintf(0, 0, fmt, argptr) + 1;
	va_end(argptr);
	va_start(argptr, fmt);
	vsprintf((char *)g_str_buf, fmt, argptr);
	va_end(argptr);
#ifdef DEBUG_ALLOC
	//puts("_STR_TMP:");
	//puts(g_str_buf);
#endif
	return tos2(g_str_buf);
} // endof _STR_TMP


array new_array(int mylen, int cap, int elm_size) {
	int cap_ = (cap == 0 ? 1 : cap);
	array arr = (array){
		.len = mylen,
		.cap = cap_,
		.element_size = elm_size,
		.data = vcalloc(cap_ * elm_size),
	};
	return arr;
}

array make(int len, int cap, int elm_size) {
	return new_array(len, cap, elm_size);
}

array new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array) {
	int cap_ = (cap == 0 ? 1 : cap);
	array arr = (array){
		.len = len,
		.cap = cap,
		.element_size = elm_size,
		.data = vcalloc(cap_ * elm_size),
	};
	memcpy(arr.data, c_array, len * elm_size);
	return arr;
}

array new_array_from_c_array_no_alloc(int len, int cap, int elm_size, voidptr c_array) {
	array arr = (array){
		.len = len,
		.cap = cap,
		.element_size = elm_size,
		.data = c_array,
	};
	return arr;
}

void array_ensure_cap(array* a, int required) {
	if (required <= a->cap) {
		return;
	}
	int cap = (a->cap == 0 ? 2 : a->cap * 2);
	while (required > cap) {
		cap *= 2;
	}
	if (a->cap == 0) {
		a->data = vcalloc(cap * a->element_size);
	} else {
		a->data = realloc(a->data, cap * a->element_size);
	}
	a->cap = cap;
}

array array_repeat(array a, int count) {
	if (count < 0) {
		v_panic(_STR("array.repeat: count is negative: %d", count));
	}
	int size = count * a.len * a.element_size;
	if (size == 0) {
		size = a.element_size;
	}
	array arr = (array){
		.len = count * a.len,
		.cap = count * a.len,
		.element_size = a.element_size,
		.data = vcalloc(size),
	};
	for (int tmp3 = 0; tmp3 < count; tmp3++) {
		int i = tmp3;
		memcpy(((byteptr)(arr.data)) + i * a.len * a.element_size, ((byteptr)(a.data)), a.len * a.element_size);
	}
	return arr;
}

void array_sort_with_compare(array* a, voidptr compare) {
	qsort(a->data, a->len, a->element_size, compare);
}

void array_insert(array* a, int i, voidptr val) {
	
#ifndef NO_BOUNDS_CHECK
	// #if not no_bounds_checking
		if (i < 0 || i > a->len) {
			v_panic(_STR("array.insert: index out of range (i == %d, a.len == %d)", i, a->len));
		}
	
#endif
	array_ensure_cap(a, a->len + 1);
	int size = a->element_size;
	memmove(((byteptr)(a->data)) + (i + 1) * size, ((byteptr)(a->data)) + i * size, (a->len - i) * size);
	memcpy(((byteptr)(a->data)) + i * size, val, size);
	a->len++;
}

void array_prepend(array* a, voidptr val) {
	array_insert(a, 0, val);
}

void array_delete(array* a, int i) {
	
#ifndef NO_BOUNDS_CHECK
	// #if not no_bounds_checking
		if (i < 0 || i >= a->len) {
			v_panic(_STR("array.delete: index out of range (i == %d, a.len == %d)", i, a->len));
		}
	
#endif
	int size = a->element_size;
	memmove(((byteptr)(a->data)) + i * size, ((byteptr)(a->data)) + (i + 1) * size, (a->len - i) * size);
	a->len--;
}

void array_clear(array* a) {
	a->len = 0;
}

void array_trim(array* a, int index) {
	if (index < a->len) {
		a->len = index;
	}
}

voidptr array_get(array a, int i) {
	
#ifndef NO_BOUNDS_CHECK
	// #if not no_bounds_checking
		if (i < 0 || i >= a.len) {
			v_panic(_STR("array.get: index out of range (i == %d, a.len == %d)", i, a.len));
		}
	
#endif
	return ((byteptr)(a.data)) + i * a.element_size;
}

voidptr array_first(array a) {
	
#ifndef NO_BOUNDS_CHECK
	// #if not no_bounds_checking
		if (a.len == 0) {
			v_panic(tos3("array.first: array is empty"));
		}
	
#endif
	return a.data;
}

voidptr array_last(array a) {
	
#ifndef NO_BOUNDS_CHECK
	// #if not no_bounds_checking
		if (a.len == 0) {
			v_panic(tos3("array.last: array is empty"));
		}
	
#endif
	return ((byteptr)(a.data)) + (a.len - 1) * a.element_size;
}

array array_slice(array a, int start, int _end) {
	int end = _end;
	
#ifndef NO_BOUNDS_CHECK
	// #if not no_bounds_checking
		if (start > end) {
			v_panic(_STR("array.slice: invalid slice index (%d > %d)", start, end));
		}
		if (end > a.len) {
			v_panic(_STR("array.slice: slice bounds out of range (%d >= %d)", end, a.len));
		}
		if (start < 0) {
			v_panic(_STR("array.slice: slice bounds out of range (%d < 0)", start));
		}
	
#endif
	int l = end - start;
	array res = (array){
		.element_size = a.element_size,
		.data = ((byteptr)(a.data)) + start * a.element_size,
		.len = l,
		.cap = l,
	};
	return res;
}

array array_slice2(array a, int start, int _end, bool end_max) {
	int end = (end_max ? a.len : _end);
	return array_slice(a, start, end);
}

array array_clone(array* a) {
	int size = a->cap * a->element_size;
	if (size == 0) {
		size++;
	}
	array arr = (array){
		.len = a->len,
		.cap = a->cap,
		.element_size = a->element_size,
		.data = vcalloc(size),
	};
	memcpy(((byteptr)(arr.data)), a->data, a->cap * a->element_size);
	return arr;
}

array array_slice_clone(array* a, int start, int _end) {
	int end = _end;
	
#ifndef NO_BOUNDS_CHECK
	// #if not no_bounds_checking
		if (start > end) {
			v_panic(_STR("array.slice: invalid slice index (%d > %d)", start, end));
		}
		if (end > a->len) {
			v_panic(_STR("array.slice: slice bounds out of range (%d >= %d)", end, a->len));
		}
		if (start < 0) {
			v_panic(_STR("array.slice: slice bounds out of range (%d < 0)", start));
		}
	
#endif
	int l = end - start;
	array res = (array){
		.element_size = a->element_size,
		.data = ((byteptr)(a->data)) + start * a->element_size,
		.len = l,
		.cap = l,
	};
	return array_clone(&res);
}

void array_set(array* a, int i, voidptr val) {
	
#ifndef NO_BOUNDS_CHECK
	// #if not no_bounds_checking
		if (i < 0 || i >= a->len) {
			v_panic(_STR("array.set: index out of range (i == %d, a.len == %d)", i, a->len));
		}
	
#endif
	memcpy(((byteptr)(a->data)) + a->element_size * i, val, a->element_size);
}

void array_push(array* a, voidptr val) {
	array_ensure_cap(a, a->len + 1);
	memcpy(((byteptr)(a->data)) + a->element_size * a->len, val, a->element_size);
	a->len++;
}

void array_push_many(array* a3, voidptr val, int size) {
	if (a3->data == val) {
		array copy = array_clone(a3);
		array_ensure_cap(a3, a3->len + size);
		memcpy(((byteptr)(a3->data)) + a3->element_size * a3->len, copy.data, a3->element_size * size);
	} else {
		array_ensure_cap(a3, a3->len + size);
		memcpy(((byteptr)(a3->data)) + a3->element_size * a3->len, val, a3->element_size * size);
	}
	a3->len += size;
}

array array_reverse(array a) {
	if (a.len < 2) {
		return a;
	}
	array arr = (array){
		.len = a.len,
		.cap = a.cap,
		.element_size = a.element_size,
		.data = vcalloc(a.cap * a.element_size),
	};
	for (int tmp2 = 0; tmp2 < a.len; tmp2++) {
		int i = tmp2;
		memcpy(((byteptr)(arr.data)) + i * arr.element_size, ((byteptr)(a.data)) + (a.len - 1 - i) * arr.element_size, arr.element_size);
	}
	return arr;
}

//[unsafe_fn]
void array_free(array a) {
	free(a.data);
}

string array_string_str(array_string a) {
	strings__Builder sb = strings__new_builder(a.len * 3);
	strings__Builder_write(&sb, tos3("["));
	for (int tmp1 = 0; tmp1 < a.len; tmp1++) {
		int i = tmp1;
		string val = (*(string*)array_get(a, i));
		strings__Builder_write(&sb, tos3("\""));
		strings__Builder_write(&sb, val);
		strings__Builder_write(&sb, tos3("\""));
		if (i < a.len - 1) {
			strings__Builder_write(&sb, tos3(", "));
		}
	}
	strings__Builder_write(&sb, tos3("]"));
	return strings__Builder_str(&sb);
}

string array_int_str(array_int a) {
	strings__Builder sb = strings__new_builder(a.len * 13);
	strings__Builder_write(&sb, tos3("["));
	for (int tmp1 = 0; tmp1 < a.len; tmp1++) {
		int i = tmp1;
		string val = int_str((*(int*)array_get(a, i)));
		strings__Builder_write(&sb, val);
		if ((*(int*)array_get(a, i)) != 0) {
			string_free(val);
		}
		if (i < a.len - 1) {
			strings__Builder_write(&sb, tos3(", "));
		}
	}
	strings__Builder_write(&sb, tos3("]"));
	return strings__Builder_str(&sb);
}

string array_bool_str(array_bool a) {
	strings__Builder sb = strings__new_builder(a.len * 3);
	strings__Builder_write(&sb, tos3("["));
	for (int tmp1 = 0; tmp1 < a.len; tmp1++) {
		int i = tmp1;
		bool val = (*(bool*)array_get(a, i));
		if (val) {
			strings__Builder_write(&sb, tos3("true"));
		} else {
			strings__Builder_write(&sb, tos3("false"));
		}
		if (i < a.len - 1) {
			strings__Builder_write(&sb, tos3(", "));
		}
	}
	strings__Builder_write(&sb, tos3("]"));
	return strings__Builder_str(&sb);
}

string array_byte_hex(array_byte b) {
	byteptr hex = v_malloc(b.len * 2 + 1);
	int dst_i = 0;
	// FOR IN
	for (int tmp1 = 0; tmp1 < b.
	len; tmp1++) {	byte i = ((byte*)b.
	data)[tmp1];byte n0 = i >> 4;
		hex[dst_i++] = (n0 < 10 ? n0 + '0' : n0 + 87);
		byte n1 = (i & 0xF);
		hex[dst_i++] = (n1 < 10 ? n1 + '0' : n1 + 87);
	}
	hex[dst_i] = '\0';
	return tos(hex, dst_i);
}

int copy(array_byte dst, array_byte src) {
	if (dst.len > 0 && src.len > 0) {
		int min = 0;
		min = (dst.len < src.len ? dst.len : src.len);
		memcpy(((byteptr)(dst.data)), array_slice(src, 0, min).data, dst.element_size * min);
		return min;
	}
	return 0;
}

int compare_ints(int* a, int* b) {
	if (*a < *b) {
		return -1;
	}
	if (*a > *b) {
		return 1;
	}
	return 0;
}

void array_int_sort(array_int* a) {
	array_sort_with_compare(a, &/*qq*/compare_ints);
}

int array_string_index(array_string a, string v) {
	for (int tmp1 = 0; tmp1 < a.len; tmp1++) {
		int i = tmp1;
		if (string_eq((*(string*)array_get(a, i)), v)) {
			return i;
		}
	}
	return -1;
}

int array_int_index(array_int a, int v) {
	for (int tmp1 = 0; tmp1 < a.len; tmp1++) {
		int i = tmp1;
		if ((*(int*)array_get(a, i)) == v) {
			return i;
		}
	}
	return -1;
}

int array_byte_index(array_byte a, byte v) {
	for (int tmp1 = 0; tmp1 < a.len; tmp1++) {
		int i = tmp1;
		if ((*(byte*)array_get(a, i)) == v) {
			return i;
		}
	}
	return -1;
}

int array_char_index(array_char a, char v) {
	for (int tmp1 = 0; tmp1 < a.len; tmp1++) {
		int i = tmp1;
		if ((*(char*)array_get(a, i)) == v) {
			return i;
		}
	}
	return -1;
}

int array_int_reduce(array_int a, int (*iter)(int accum, int curr), int accum_start) {
	int accum_ = accum_start;
	// FOR IN
	for (int tmp1 = 0; tmp1 < a.
	len; tmp1++) {	int i = ((int*)a.
	data)[tmp1];accum_ = iter(accum_, i);
	}
	return accum_;
}

bool array_string_eq(array_string a1, array_string a2) {
	if (a1.len != a2.len) {
		return false;
	}
	for (int tmp2 = 0; tmp2 < a1.len; tmp2++) {
		int i = tmp2;
		if (string_ne((*(string*)array_get(a1, i)), (*(string*)array_get(a2, i)))) {
			return false;
		}
	}
	return true;
}

int compare_i64(i64* a, i64* b) {
	if (*a < *b) {
		return -1;
	}
	if (*a > *b) {
		return 1;
	}
	return 0;
}

int compare_f64(f64* a, f64* b) {
	if (*a < *b) {
		return -1;
	}
	if (*a > *b) {
		return 1;
	}
	return 0;
}

int compare_f32(f32* a, f32* b) {
	if (*a < *b) {
		return -1;
	}
	if (*a > *b) {
		return 1;
	}
	return 0;
}

array_voidptr array_pointers(array a) {
	array_voidptr res = new_array(0, 0, sizeof(voidptr));
	for (int tmp1 = 0; tmp1 < a.len; tmp1++) {
		int i = tmp1;
		_PUSH(&res, (((byteptr)(a.data)) + i * a.element_size), tmp2, voidptr);
	}
	return res;
}

void v_exit(int code) {
	exit(code);
}

bool isnil(voidptr v) {
	return v == 0;
}

void print_backtrace_skipping_top_frames(int skipframes) {
	
#ifdef _WIN32
	// #if windows
		
#ifdef _MSC_VER
		// #if msvc
			if (print_backtrace_skipping_top_frames_msvc(skipframes)) {
				return;
			}
		
#endif
		
#ifdef __MINGW32__
		// #if mingw
			if (print_backtrace_skipping_top_frames_mingw(skipframes)) {
				return;
			}
		
#endif
	
#else
		if (print_backtrace_skipping_top_frames_nix(skipframes)) {
			return;
		}
	
#endif
	println(tos3("print_backtrace_skipping_top_frames is not implemented on this platform for now...\n"));
}

void print_backtrace() {
	print_backtrace_skipping_top_frames(2);
}

void panic_debug(int line_no, string file, string mod, string fn_name, string s) {
	println(tos3("================ V panic ================"));
	println(_STR("   module: %.*s", mod.len, mod.str));
	println(_STR(" function: %.*s()", fn_name.len, fn_name.str));
	println(_STR("     file: %.*s", file.len, file.str));
	println(string_add(tos3("     line: "), int_str(line_no)));
	println(_STR("  message: %.*s", s.len, s.str));
	println(tos3("========================================="));
	print_backtrace_skipping_top_frames(1);
	exit(1);
}

void v_panic(string s) {
	println(_STR("V panic: %.*s", s.len, s.str));
	print_backtrace();
	exit(1);
}

void eprintln(string s) {
	if (isnil(s.str)) {
		v_panic(tos3("eprintln(NIL)"));
	}
	
#ifndef _WIN32
	// #if not windows
		fflush(stdout);
		fflush(stderr);
		fprintf(stderr, "%.*s\n", s.len, s.str);
		fflush(stderr);
		return;
	
#endif
	println(s);
}

void eprint(string s) {
	if (isnil(s.str)) {
		v_panic(tos3("eprint(NIL)"));
	}
	
#ifndef _WIN32
	// #if not windows
		fflush(stdout);
		fflush(stderr);
		fprintf(stderr, "%.*s", s.len, s.str);
		fflush(stderr);
		return;
	
#endif
	print(s);
}

void print(string s) {
	
#ifdef _WIN32
	// #if windows
		voidptr output_handle = GetStdHandle(STD_OUTPUT_HANDLE);
		int bytes_written = 0;
		if (is_atty(1) > 0) {
			u16* wide_str = string_to_wide(s);
			int wide_len = wcslen(wide_str);
			WriteConsole(output_handle, wide_str, wide_len, &bytes_written, 0);
		} else {
			WriteFile(output_handle, s.str, s.len, &bytes_written, 0);
		}
	
#else
		printf("%.*s", s.len, s.str);
	
#endif
}

void looo() {
}

//[unsafe_fn]
byteptr v_malloc(int n) {
	if (n <= 0) {
		v_panic(tos3("malloc(<=0)"));
	}
	
#ifdef VPREALLOC
	// #if prealloc
		byteptr res = g_m2_ptr;
		g_m2_ptr += n;
		nr_mallocs++;
		return res;
	
#else
		byteptr ptr = malloc(n);
		if (ptr == 0) {
			v_panic(_STR("malloc(%d) failed", n));
		}
		return ptr;
	
#endif
}

byteptr v_calloc(int n) {
	return calloc(n, 1);
}

byteptr vcalloc(int n) {
	if (n <= 0) {
		v_panic(tos3("calloc(<=0)"));
	}
	return calloc(n, 1);
}

//[unsafe_fn]
void v_free(voidptr ptr) {
	free(ptr);
}

voidptr memdup(voidptr src, int sz) {
	if (sz == 0) {
		return vcalloc(1);
	}
	byteptr mem = v_malloc(sz);
	return memcpy(mem, src, sz);
}

void v_ptr_free(voidptr ptr) {
	free(ptr);
}

int is_atty(int fd) {
	
#ifdef _WIN32
	// #if windows
		u32 mode = ((u32)(0));
		voidptr osfh = ((voidptr)(_get_osfhandle(fd)));
		GetConsoleMode(osfh, ((voidptr)(&mode)));
		return ((int)(mode));
	
#else
		return isatty(fd);
	
#endif
}

void builtin_init() {
}

void println(string s) {
	printf("%.*s\n", s.len, s.str);
}

bool print_backtrace_skipping_top_frames_msvc(int skipframes) {
	println(tos3("not implemented, see builtin_windows.v"));
	return false;
}

bool print_backtrace_skipping_top_frames_mingw(int skipframes) {
	println(tos3("not implemented, see builtin_windows.v"));
	return false;
}

bool print_backtrace_skipping_top_frames_nix(int xskipframes) {
	int skipframes = xskipframes + 2;
	
#ifdef __APPLE__
	// #if macos
		return print_backtrace_skipping_top_frames_mac(skipframes);
	
#endif
	
#ifdef __linux__
	// #if linux
		return print_backtrace_skipping_top_frames_linux(skipframes);
	
#endif
	
#ifdef __FreeBSD__
	// #if freebsd
		return print_backtrace_skipping_top_frames_freebsd(skipframes);
	
#endif
	
#ifdef __NetBSD__
	// #if netbsd
		return print_backtrace_skipping_top_frames_freebsd(skipframes);
	
#endif
	
#ifdef __OpenBSD__
	// #if openbsd
		return print_backtrace_skipping_top_frames_freebsd(skipframes);
	
#endif
	return false;
}

bool print_backtrace_skipping_top_frames_mac(int skipframes) {
	
#ifdef __APPLE__
	// #if macos
		array_fixed_byteptr_100 buffer= {0};
		int nr_ptrs = backtrace(&/*qq*/buffer, 100);
		backtrace_symbols_fd(&buffer[skipframes], nr_ptrs - skipframes, 1);
	
#endif
	return true;
}

bool print_backtrace_skipping_top_frames_freebsd(int skipframes) {
	
#ifdef __FreeBSD__
	// #if freebsd
		array_fixed_byteptr_100 buffer= {0};
		int nr_ptrs = backtrace(&/*qq*/buffer, 100);
		backtrace_symbols_fd(&buffer[skipframes], nr_ptrs - skipframes, 1);
	
#endif
	return true;
}

bool print_backtrace_skipping_top_frames_linux(int skipframes) {
	
#ifdef __TINYC__
	// #if tinyc
		println(_STR("TODO: print_backtrace_skipping_top_frames_linux %d with tcc fails tests with \"stack smashing detected\" .", skipframes));
		return false;
	
#endif
	
#ifndef __ANDROID__
	// #if not android
		
#ifdef __GLIBC__
		// #if glibc
			array_fixed_byteptr_100 buffer= {0};
			int nr_ptrs = backtrace(&/*qq*/buffer, 100);
			int nr_actual_frames = nr_ptrs - skipframes;
			array_string sframes = new_array(0, 0, sizeof(string));
			byteptr* csymbols = backtrace_symbols(&buffer[skipframes], nr_actual_frames);
			for (int tmp1 = 0; tmp1 < nr_actual_frames; tmp1++) {
				int i = tmp1;
				_PUSH(&sframes, (tos2(((byteptr)(((voidptr)(csymbols[i])))))), tmp2, string);
			}
			// FOR IN
			for (int tmp3 = 0; tmp3 < sframes.
			len; tmp3++) {	string sframe = ((string*)sframes.
			data)[tmp3];string executable = string_all_before(sframe, tos3("("));
				string addr = string_all_before(string_all_after(sframe, tos3("[")), tos3("]"));
				string beforeaddr = string_all_before(sframe, tos3("["));
				string cmd = _STR("addr2line -e %.*s %.*s", executable.len, executable.str, addr.len, addr.str);
				voidptr f = popen(cmd.str, "r");
				if (isnil(f)) {
					println(sframe);
					continue;
				}
				array_fixed_byte_1000 buf= {0};
				string output = tos3("");
				while (fgets(((charptr)(buf)), 1000, f) != 0) {
					output = string_add(output, tos(&/*qq*/buf, vstrlen(&/*qq*/buf)));
				}
				output = string_add(string_trim_space(output), tos3(":"));
				if (pclose(f) != 0) {
					println(sframe);
					continue;
				}
				if ((string_eq(output, tos3("??:0:")) || string_eq(output, tos3("??:?:")))) {
					output = tos3("");
				}
				output = string_replace(output, tos3(" (discriminator"), tos3(": (d."));
				println(_STR("%-46s | %14s | %.*s", output.str, addr.str, beforeaddr.len, beforeaddr.str));
			}
			return true;
		
#else
			println(tos3("backtrace_symbols_fd is missing, so printing backtraces is not available.\n"));
			println(tos3("Some libc implementations like musl simply do not provide it."));
		
#endif
	
#endif
	return false;
}













int backtrace(voidptr a, int b);

byteptr* backtrace_symbols(voidptr, int);

void backtrace_symbols_fd(voidptr, int, int);

int proc_pidpath(int, voidptr, int);



























































































































inline
string f64_str(f64 d) {
	return strconv__ftoa__ftoa_64(d);
}

inline
string f64_strsci(f64 x, int digit_num) {
	int n_digit = digit_num;
	if (n_digit < 1) {
		n_digit = 1;
	} else if (n_digit > 17) {
		n_digit = 17;
	}
	return strconv__ftoa__f64_to_str(x, n_digit);
}

inline
string f64_strlong(f64 x) {
	return strconv__ftoa__f64_to_str_l(x);
}

inline
string f32_str(f32 d) {
	return strconv__ftoa__ftoa_32(d);
}

inline
string f32_strsci(f32 x, int digit_num) {
	int n_digit = digit_num;
	if (n_digit < 1) {
		n_digit = 1;
	} else if (n_digit > 8) {
		n_digit = 8;
	}
	return strconv__ftoa__f32_to_str(x, n_digit);
}

inline
string f32_strlong(f32 x) {
	return strconv__ftoa__f32_to_str_l(x);
}

inline
f32 f32_abs(f32 a) {
	return (a < 0 ? -a : a);
}

inline
f64 f64_abs(f64 a) {
	return (a < 0 ? -a : a);
}

inline
bool f64_eq(f64 a, f64 b) {
	return f64_abs(a - b) <= DBL_EPSILON;
}

inline
bool f32_eq(f32 a, f32 b) {
	return f32_abs(a - b) <= FLT_EPSILON;
}

bool f64_eqbit(f64 a, f64 b) {
	return DEFAULT_EQUAL(a, b);
}

bool f32_eqbit(f32 a, f32 b) {
	return DEFAULT_EQUAL(a, b);
}

bool f64_ne(f64 a, f64 b) {
	return !f64_eq(a, b);
}

bool f32_ne(f32 a, f32 b) {
	return !f32_eq(a, b);
}

bool f64_nebit(f64 a, f64 b) {
	return DEFAULT_NOT_EQUAL(a, b);
}

bool f32_nebit(f32 a, f32 b) {
	return DEFAULT_NOT_EQUAL(a, b);
}

bool f64_lt(f64 a, f64 b) {
	return f64_ne(a, b) && f64_ltbit(a, b);
}

bool f32_lt(f32 a, f32 b) {
	return f32_ne(a, b) && f32_ltbit(a, b);
}

bool f64_ltbit(f64 a, f64 b) {
	return DEFAULT_LT(a, b);
}

bool f32_ltbit(f32 a, f32 b) {
	return DEFAULT_LT(a, b);
}

bool f64_le(f64 a, f64 b) {
	return !f64_gt(a, b);
}

bool f32_le(f32 a, f32 b) {
	return !f32_gt(a, b);
}

bool f64_lebit(f64 a, f64 b) {
	return DEFAULT_LE(a, b);
}

bool f32_lebit(f32 a, f32 b) {
	return DEFAULT_LE(a, b);
}

bool f64_gt(f64 a, f64 b) {
	return f64_ne(a, b) && f64_gtbit(a, b);
}

bool f32_gt(f32 a, f32 b) {
	return f32_ne(a, b) && f32_gtbit(a, b);
}

bool f64_gtbit(f64 a, f64 b) {
	return DEFAULT_GT(a, b);
}

bool f32_gtbit(f32 a, f32 b) {
	return DEFAULT_GT(a, b);
}

bool f64_ge(f64 a, f64 b) {
	return !f64_lt(a, b);
}

bool f32_ge(f32 a, f32 b) {
	return !f32_lt(a, b);
}

bool f64_gebit(f64 a, f64 b) {
	return DEFAULT_GE(a, b);
}

bool f32_gebit(f32 a, f32 b) {
	return DEFAULT_GE(a, b);
}

string ptr_str(voidptr ptr) {
	string buf1 = u64_hex(((u64)(ptr)));
	return buf1;
}

inline
string int_str_l(int nn, int max) {
	int n = nn;
	int d = 0;
	if (n == 0) {
		return tos3("0");
	}
	byteptr buf = v_malloc(max + 1);
	bool is_neg = false;
	if (n < 0) {
		n = -n;
		is_neg = true;
	}
	int index = max;
	buf[index--] = '\0';
	while (n > 0) {
		int n1 = n / 100;
		d = ((n - (n1 * 100)) << 1);
		n = n1;
		buf[index--] = _const_digit_pairs.str[d++];
		buf[index--] = _const_digit_pairs.str[d];
	}
	index++;
	if (d < 20) {
		index++;
	}
	if (is_neg) {
		index--;
		buf[index] = '-';
	}
	memmove(buf, buf + index, (max - index) + 1);
	return tos(buf, (max - index));
}

string i8_str(i8 n) {
	return int_str_l(((int)(n)), 5);
}

string i16_str(i16 n) {
	return int_str_l(((int)(n)), 7);
}

string u16_str(u16 n) {
	return int_str_l(((int)(n)), 7);
}

string int_str(int n) {
	return int_str_l(n, 12);
}

string u32_str(u32 nn) {
	u32 n = nn;
	u32 d = ((u32)(0));
	if (n == 0) {
		return tos3("0");
	}
	int max = 12;
	byteptr buf = v_malloc(max + 1);
	int index = max;
	buf[index--] = '\0';
	while (n > 0) {
		u32 n1 = n / ((u32)(100));
		d = ((n - (n1 * ((u32)(100)))) << ((u32)(1)));
		n = n1;
		buf[index--] = string_at(_const_digit_pairs, d++);
		buf[index--] = string_at(_const_digit_pairs, d);
	}
	index++;
	if (d < ((u32)(20))) {
		index++;
	}
	memmove(buf, buf + index, (max - index) + 1);
	return tos(buf, (max - index));
}

string i64_str(i64 nn) {
	i64 n = nn;
	i64 d = ((i64)(0));
	if (n == 0) {
		return tos3("0");
	}
	int max = 20;
	byteptr buf = vcalloc(max + 1);
	bool is_neg = false;
	if (n < 0) {
		n = -n;
		is_neg = true;
	}
	int index = max;
	buf[index--] = '\0';
	while (n > 0) {
		i64 n1 = n / ((i64)(100));
		d = ((n - (n1 * ((i64)(100)))) << ((i64)(1)));
		n = n1;
		buf[index--] = string_at(_const_digit_pairs, d++);
		buf[index--] = string_at(_const_digit_pairs, d);
	}
	index++;
	if (d < ((i64)(20))) {
		index++;
	}
	if (is_neg) {
		index--;
		buf[index] = '-';
	}
	memmove(buf, buf + index, (max - index) + 1);
	return tos(buf, (max - index));
}

string u64_str(u64 nn) {
	u64 n = nn;
	int d = 0;
	if (n == 0) {
		return tos3("0");
	}
	int max = 20;
	byteptr buf = vcalloc(max + 1);
	int index = max;
	buf[index--] = '\0';
	while (n > 0) {
		u64 n1 = n / 100;
		d = ((n - (n1 * 100)) << 1);
		n = n1;
		buf[index--] = string_at(_const_digit_pairs, d++);
		buf[index--] = string_at(_const_digit_pairs, d);
	}
	index++;
	if (d < 20) {
		index++;
	}
	memmove(buf, buf + index, (max - index) + 1);
	return tos(buf, (max - index));
}

string bool_str(bool b) {
	if (b) {
		return tos3("true");
	}
	return tos3("false");
}

string byte_hex(byte nn) {
	if (nn == 0) {
		return tos3("0");
	}
	byte n = nn;
	int max = 2;
	byteptr buf = v_malloc(max + 1);
	int index = max;
	buf[index--] = '\0';
	while (n > 0) {
		byte d = (n & 0xF);
		n = n >> 4;
		buf[index--] = (d < 10 ? d + '0' : d + 87);
	}
	index++;
	return tos(buf + index, (max - index));
}

string i8_hex(i8 nn) {
	return byte_hex(((byte)(nn)));
}

string u16_hex(u16 nn) {
	if (nn == 0) {
		return tos3("0");
	}
	u16 n = nn;
	int max = 5;
	byteptr buf = v_malloc(max + 1);
	int index = max;
	buf[index--] = '\0';
	while (n > 0) {
		u16 d = (n & 0xF);
		n = n >> 4;
		buf[index--] = (d < 10 ? d + '0' : d + 87);
	}
	index++;
	return tos(buf + index, (max - index));
}

string i16_hex(i16 nn) {
	return u16_hex(((u16)(nn)));
}

string u32_hex(u32 nn) {
	if (nn == 0) {
		return tos3("0");
	}
	u32 n = nn;
	int max = 10;
	byteptr buf = v_malloc(max + 1);
	int index = max;
	buf[index--] = '\0';
	while (n > 0) {
		u32 d = (n & 0xF);
		n = n >> 4;
		buf[index--] = (d < 10 ? d + '0' : d + 87);
	}
	index++;
	return tos(buf + index, (max - index));
}

string int_hex(int nn) {
	return u32_hex(((u32)(nn)));
}

string u64_hex(u64 nn) {
	if (nn == 0) {
		return tos3("0");
	}
	u64 n = nn;
	int max = 18;
	byteptr buf = v_malloc(max + 1);
	int index = max;
	buf[index--] = '\0';
	while (n > 0) {
		u64 d = (n & 0xF);
		n = n >> 4;
		buf[index--] = (d < 10 ? d + '0' : d + 87);
	}
	index++;
	memmove(buf, buf + index, (max - index) + 1);
	return tos(buf, (max - index));
}

string i64_hex(i64 nn) {
	return u64_hex(((u64)(nn)));
}

bool array_byte_contains(array_byte a, byte val) {
	// FOR IN
	for (int tmp1 = 0; tmp1 < a.
	len; tmp1++) {	byte aa = ((byte*)a.
	data)[tmp1];if (aa == val) {
			return true;
		}
	}
	return false;
}

string rune_str(rune c) {
	int fst_byte = (((int)(c)) >> 8 * 3 & 0xff);
	int len = utf8_char_len(fst_byte);
	string str = (string){
		.len = len,
		.str = v_malloc(len + 1),
	};
	for (int tmp1 = 0; tmp1 < len; tmp1++) {
		int i = tmp1;
		str.str[i] = (((int)(c)) >> 8 * (3 - i) & 0xff);
	}
	str.str[len] = '\0';
	return str;
}

string byte_str(byte c) {
	string str = (string){
		.len = 1,
		.str = v_malloc(2),
	};
	str.str[0] = c;
	str.str[1] = '\0';
	return str;
}

bool byte_is_capital(byte c) {
	return c >= 'A' && c <= 'Z';
}

array_byte array_byte_clone(array_byte b) {
	array_byte res = array_repeat(new_array_from_c_array(1, 1, sizeof(byte), (byte[1]){
		((byte)(0)), 
}), b.len);
	for (int tmp1 = 0; tmp1 < b.len; tmp1++) {
		int i = tmp1;
		array_set(&res, i, &(byte[]) { (*(byte*)array_get(b, i)) });
	}
	return res;
}


inline
DenseArray new_dense_array() {
		return (DenseArray){
			.cap = 8,
			.size = 0,
			.deletes = 0,
			.data = ((KeyValue*)(v_malloc(8 * sizeof(KeyValue)))),
		};
}

inline
u32 DenseArray_push(DenseArray* d, KeyValue kv) {
	if (d->cap == d->size) {
		d->cap += d->cap >> 3;
		d->data = ((KeyValue*)(realloc(d->data, sizeof(KeyValue) * d->cap)));
	}
	u32 push_index = d->size;
	d->data[push_index] = kv;
	d->size++;
	return push_index;
}

void DenseArray_zeros_to_end(DenseArray* d) {
	u32 count = ((u32)(0));
	for (int tmp1 = 0; tmp1 < d->size; tmp1++) {
		int i = tmp1;
		if (d->data[i].key.str != 0) {
			KeyValue tmp = d->data[count];
			d->data[count] = d->data[i];
			d->data[i] = tmp;
			count++;
		}
	}
	d->deletes = 0;
	d->size = count;
	d->cap = (count < 8 ? 8 : count);
	d->data = ((KeyValue*)(realloc(d->data, sizeof(KeyValue) * d->cap)));
}

map new_map(int n, int value_bytes) {
	return (map){
		.value_bytes = value_bytes,
		.cap = _const_init_cap,
		.cached_hashbits = _const_max_cached_hashbits,
		.shift = _const_init_log_capicity,
		.key_values = new_dense_array(),
		.metas = ((u32*)(vcalloc(sizeof(u32) * (_const_init_capicity + _const_extra_metas_inc)))),
		.extra_metas = _const_extra_metas_inc,
		.size = 0,
	};
}

map new_map_init(int n, int value_bytes, string* keys, voidptr values) {
	map out = new_map(n, value_bytes);
	for (int tmp1 = 0; tmp1 < n; tmp1++) {
		int i = tmp1;
		map_set(&out, keys[i], ((byteptr)(values)) + i * value_bytes);
	}
	return out;
}

inline
multi_return_u32_u32 map_key_to_index(map m, string key) {
	u64 hash = hash__wyhash__wyhash_c(key.str, ((u64)(key.len)), 0);
	u64 index = (hash & m.cap);
	u64 meta = ((((hash >> m.shift) & _const_hash_mask)) | _const_probe_inc);
	return (multi_return_u32_u32){.arg0=((u32)(index)),.arg1=((u32)(meta))};
}

inline
multi_return_u32_u32 map_meta_less(map m, u32 _index, u32 _metas) {
	u32 index = _index;
	u32 meta = _metas;
	while (meta < m.metas[index]) {
		index += 2;
		meta += _const_probe_inc;
	}
	return (multi_return_u32_u32){.arg0=index,.arg1=meta};
}

inline
void map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi) {
	u32 meta = _metas;
	u32 index = _index;
	u32 kv_index = kvi;
	while (m->metas[index] != 0) {
		if (meta > m->metas[index]) {
			u32 tmp_meta = m->metas[index];
			m->metas[index] = meta;
			meta = tmp_meta;
			u32 tmp_index = m->metas[index + 1];
			m->metas[index + 1] = kv_index;
			kv_index = tmp_index;
		}
		index += 2;
		meta += _const_probe_inc;
	}
	m->metas[index] = meta;
	m->metas[index + 1] = kv_index;
	u32 probe_count = (meta >> _const_hashbits) - 1;
	if ((probe_count << 1) == m->extra_metas) {
		m->extra_metas += _const_extra_metas_inc;
		u32 mem_size = (m->cap + 2 + m->extra_metas);
		m->metas = ((u32*)(realloc(m->metas, sizeof(u32) * mem_size)));
		memset(m->metas + mem_size - _const_extra_metas_inc, 0, sizeof(u32) * _const_extra_metas_inc);
		if (probe_count == 252) {
			v_panic(tos3("Probe overflow"));
		}
	}
}

void map_set(map* m, string key, voidptr value) {
	f32 load_factor = ((f32)(m->size << 1)) / ((f32)(m->cap));
	if (load_factor > _const_max_load_factor) {
		map_expand(m);
	}
	multi_return_u32_u32 mr_7176 = map_key_to_index(/*rec*/*m, key);
	u32 index = mr_7176.arg0;
	u32 meta = mr_7176.arg1;
	multi_return_u32_u32 mr_7210 = map_meta_less(/*rec*/*m, index, meta);
	index = mr_7210.arg0;
	meta = mr_7210.arg1;
	while (meta == m->metas[index]) {
		u32 kv_index = m->metas[index + 1];
		if (strcmp(key.str, m->key_values.data[kv_index].key.str) == 0) {
			memcpy(m->key_values.data[kv_index].value, value, m->value_bytes);
			return;
		}
		index += 2;
		meta += _const_probe_inc;
	}
	KeyValue kv = (KeyValue){
		.key = key,
		.value = v_malloc(m->value_bytes),
	};
	memcpy(kv.value, value, m->value_bytes);
	u32 kv_index = DenseArray_push(&m->key_values, kv);
	map_meta_greater(m, index, meta, kv_index);
	m->size++;
}

void map_expand(map* m) {
	u32 old_cap = m->cap;
	m->cap = ((m->cap + 2) << 1) - 2;
	if (m->cached_hashbits == 0) {
		m->shift += _const_max_cached_hashbits;
		m->cached_hashbits = _const_max_cached_hashbits;
		map_rehash(m);
	} else {
		map_cached_rehash(m, old_cap);
	}
	m->cached_hashbits--;
}

void map_rehash(map* m) {
	int meta_bytes = sizeof(u32) * (m->cap + 2 + m->extra_metas);
	m->metas = ((u32*)(realloc(m->metas, meta_bytes)));
	memset(m->metas, 0, meta_bytes);
	for (u32 i = ((u32)(0));
	i < m->key_values.size; i++) {
		if (m->key_values.data[i].key.str == 0) {
			continue;
		}
		KeyValue kv = m->key_values.data[i];
		multi_return_u32_u32 mr_8386 = map_key_to_index(/*rec*/*m, kv.key);
		u32 index = mr_8386.arg0;
		u32 meta = mr_8386.arg1;
		multi_return_u32_u32 mr_8424 = map_meta_less(/*rec*/*m, index, meta);
		index = mr_8424.arg0;
		meta = mr_8424.arg1;
		map_meta_greater(m, index, meta, i);
	}
}

void map_cached_rehash(map* m, u32 old_cap) {
	u32* old_metas = m->metas;
	m->metas = ((u32*)(vcalloc(sizeof(u32) * (m->cap + 2 + m->extra_metas))));
	u32 old_extra_metas = m->extra_metas;
	for (u32 i = ((u32)(0));
	i <= old_cap + old_extra_metas; i += 2) {
		if (old_metas[i] == 0) {
			continue;
		}
		u32 old_meta = old_metas[i];
		u32 old_probe_count = ((old_meta >> _const_hashbits) - 1) << 1;
		u32 old_index = ((i - old_probe_count) & (m->cap >> 1));
		u32 index = (((old_index | (old_meta << m->shift))) & m->cap);
		u32 meta = (((old_meta & _const_hash_mask)) | _const_probe_inc);
		multi_return_u32_u32 mr_9005 = map_meta_less(/*rec*/*m, index, meta);
		index = mr_9005.arg0;
		meta = mr_9005.arg1;
		u32 kv_index = old_metas[i + 1];
		map_meta_greater(m, index, meta, kv_index);
	}
		v_free(old_metas);
}

voidptr map_get3(map m, string key, voidptr zero) {
	multi_return_u32_u32 mr_9212 = map_key_to_index(m, key);
	u32 index = mr_9212.arg0;
	u32 meta = mr_9212.arg1;
	multi_return_u32_u32 mr_9246 = map_meta_less(m, index, meta);
	index = mr_9246.arg0;
	meta = mr_9246.arg1;
	while (meta == m.metas[index]) {
		u32 kv_index = m.metas[index + 1];
		if (strcmp(key.str, m.key_values.data[kv_index].key.str) == 0) {
			byteptr out = v_malloc(m.value_bytes);
			memcpy(out, m.key_values.data[kv_index].value, m.value_bytes);
			return out;
		}
		index += 2;
		meta += _const_probe_inc;
	}
	return zero;
}

bool map_exists(map m, string key) {
	if (m.value_bytes == 0) {
		return false;
	}
	multi_return_u32_u32 mr_9673 = map_key_to_index(m, key);
	u32 index = mr_9673.arg0;
	u32 meta = mr_9673.arg1;
	multi_return_u32_u32 mr_9707 = map_meta_less(m, index, meta);
	index = mr_9707.arg0;
	meta = mr_9707.arg1;
	while (meta == m.metas[index]) {
		u32 kv_index = m.metas[index + 1];
		if (strcmp(key.str, m.key_values.data[kv_index].key.str) == 0) {
			return true;
		}
		index += 2;
		meta += _const_probe_inc;
	}
	return false;
}

void map_delete(map* m, string key) {
	multi_return_u32_u32 mr_9997 = map_key_to_index(/*rec*/*m, key);
	u32 index = mr_9997.arg0;
	u32 meta = mr_9997.arg1;
	multi_return_u32_u32 mr_10031 = map_meta_less(/*rec*/*m, index, meta);
	index = mr_10031.arg0;
	meta = mr_10031.arg1;
	while (meta == m->metas[index]) {
		u32 kv_index = m->metas[index + 1];
		if (strcmp(key.str, m->key_values.data[kv_index].key.str) == 0) {
			while ((m->metas[index + 2] >> _const_hashbits) > 1) {
				m->metas[index] = m->metas[index + 2] - _const_probe_inc;
				m->metas[index + 1] = m->metas[index + 3];
				index += 2;
			}
			m->size--;
			m->metas[index] = 0;
			m->key_values.deletes++;
			memset(&m->key_values.data[kv_index], 0, sizeof(KeyValue));
			if (m->key_values.size <= 32) {
				return;
			}
			if (m->key_values.deletes >= (m->key_values.size >> 1)) {
				DenseArray_zeros_to_end(&m->key_values);
				map_rehash(m);
				m->key_values.deletes = 0;
			}
			return;
		}
		index += 2;
		meta += _const_probe_inc;
	}
}

array_string map_keys(map* m) {
	array_string keys = array_repeat(new_array_from_c_array(1, 1, sizeof(string), (string[1]){
		tos3(""), 
}), m->size);
	if (m->value_bytes == 0) {
		return keys;
	}
	int j = 0;
	for (u32 i = ((u32)(0));
	i < m->key_values.size; i++) {
		if (m->key_values.data[i].key.str == 0) {
			continue;
		}
		array_set(&keys, j, &(string[]) { m->key_values.data[i].key });
		j++;
	}
	return keys;
}

//[unsafe_fn]
void map_free(map m) {
	v_free(m.metas);
	for (u32 i = ((u32)(0));
	i < m.key_values.size; i++) {
		if (m.key_values.data[i].key.str == 0) {
			continue;
		}
		string_free(m.key_values.data[i].key);
	}
	v_free(m.key_values.data);
}

void map_print(map m) {
	println(tos3("TODO"));
}

string map_string_str(map_string m) {
	if (m.size == 0) {
		return tos3("{}");
	}
	strings__Builder sb = strings__new_builder(50);
	strings__Builder_writeln(&sb, tos3("{"));
	strings__Builder_writeln(&sb, tos3("}"));
	return strings__Builder_str(&sb);
}

Option opt_ok(voidptr data, int size) {
	if (size >= 400) {
		v_panic(_STR("option size too big: %d (max is 400), this is a temporary limit", size));
	}
	Option res = (Option){
		.ok = true,
		.data = {0},
		.v_error = tos3(""),
		.ecode = 0,
		.is_none = 0,
	};
	memcpy(res.data, data, size);
	return res;
}

Option opt_none() {
	return (Option){
		.is_none = true,
		.data = {0},
		.v_error = tos3(""),
		.ecode = 0,
		.ok = 0,
	};
}

Option v_error(string s) {
	return (Option){
		.v_error = s,
		.data = {0},
		.ecode = 0,
		.ok = 0,
		.is_none = 0,
	};
}

Option error_with_code(string s, int code) {
	return (Option){
		.v_error = s,
		.ecode = code,
		.data = {0},
		.ok = 0,
		.is_none = 0,
	};
}

SortedMap new_sorted_map(int n, int value_bytes) {
	return (SortedMap){
		.value_bytes = value_bytes,
		.root = new_node(),
		.size = 0,
	};
}

SortedMap new_sorted_map_init(int n, int value_bytes, string* keys, voidptr values) {
	SortedMap out = new_sorted_map(n, value_bytes);
	for (int tmp1 = 0; tmp1 < n; tmp1++) {
		int i = tmp1;
		SortedMap_set(&out, keys[i], ((byteptr)(values)) + i * value_bytes);
	}
	return out;
}

mapnode* new_node() {
	return (mapnode*)memdup(&(mapnode){	.children = 0,
		.size = 0,
		.keys = {0},
		.values = {0},
	}, sizeof(mapnode));
}

void SortedMap_set(SortedMap* m, string key, voidptr value) {
	mapnode* node = m->root;
	int child_index = 0;
	mapnode* parent = ((mapnode*)(0));
	while (1) {
		if (node->size == _const_max_size) {
			if (isnil(parent)) {
				parent = new_node();
				m->root = parent;
			}
			mapnode_split_child(parent, child_index, node);
			if (string_eq(key, parent->keys[child_index])) {
				memcpy(parent->values[child_index], value, m->value_bytes);
				return;
			}
			node = (string_lt(key, parent->keys[child_index]) ? ((mapnode*)(parent->children[child_index])) : ((mapnode*)(parent->children[child_index + 1])));
		}
		int i = 0;
		while (i < node->size && string_gt(key, node->keys[i])) {
			i++;
		}
		if (i != node->size && string_eq(key, node->keys[i])) {
			memcpy(node->values[i], value, m->value_bytes);
			return;
		}
		if (isnil(node->children)) {
			int j = node->size - 1;
			while (j >= 0 && string_lt(key, node->keys[j])) {
				node->keys[j + 1] = node->keys[j];
				node->values[j + 1] = node->values[j];
				j--;
			}
			node->keys[j + 1] = key;
			node->values[j + 1] = v_malloc(m->value_bytes);
			memcpy(node->values[j + 1], value, m->value_bytes);
			node->size++;
			m->size++;
			return;
		}
		parent = node;
		child_index = i;
		node = ((mapnode*)(node->children[child_index]));
	}
}

void mapnode_split_child(mapnode* n, int child_index, mapnode* y) {
	mapnode* z = new_node();
	z->size = _const_mid_index;
	y->size = _const_mid_index;
	for (int j = _const_mid_index - 1;
	j >= 0; j--) {
		z->keys[j] = y->keys[j + _const_degree];
		z->values[j] = y->values[j + _const_degree];
	}
	if (!isnil(y->children)) {
		z->children = ((voidptr*)(v_malloc(_const_children_bytes)));
		for (int jj = _const_degree - 1;
		jj >= 0; jj--) {
			z->children[jj] = y->children[jj + _const_degree];
		}
	}
	if (isnil(n->children)) {
		n->children = ((voidptr*)(v_malloc(_const_children_bytes)));
	}
	n->children[n->size + 1] = n->children[n->size];
	for (int j = n->size;
	j > child_index; j--) {
		n->keys[j] = n->keys[j - 1];
		n->values[j] = n->values[j - 1];
		n->children[j] = n->children[j - 1];
	}
	n->keys[child_index] = y->keys[_const_mid_index];
	n->values[child_index] = y->values[_const_mid_index];
	n->children[child_index] = ((voidptr)(y));
	n->children[child_index + 1] = ((voidptr)(z));
	n->size++;
}

bool SortedMap_get(SortedMap m, string key, voidptr out) {
	mapnode* node = m.root;
	while (1) {
		int i = node->size - 1;
		while (i >= 0 && string_lt(key, node->keys[i])) {
			i--;
		}
		if (i != -1 && string_eq(key, node->keys[i])) {
			memcpy(out, node->values[i], m.value_bytes);
			return true;
		}
		if (isnil(node->children)) {
			break;
		}
		node = ((mapnode*)(node->children[i + 1]));
	}
	return false;
}

bool SortedMap_exists(SortedMap m, string key) {
	if (isnil(m.root)) {
		return false;
	}
	mapnode* node = m.root;
	while (1) {
		int i = node->size - 1;
		while (i >= 0 && string_lt(key, node->keys[i])) {
			i--;
		}
		if (i != -1 && string_eq(key, node->keys[i])) {
			return true;
		}
		if (isnil(node->children)) {
			break;
		}
		node = ((mapnode*)(node->children[i + 1]));
	}
	return false;
}

int mapnode_find_key(mapnode* n, string k) {
	int idx = 0;
	while (idx < n->size && string_lt(n->keys[idx], k)) {
		idx++;
	}
	return idx;
}

bool mapnode_remove_key(mapnode* n, string k) {
	int idx = mapnode_find_key(n, k);
	if (idx < n->size && string_eq(n->keys[idx], k)) {
		if (isnil(n->children)) {
			mapnode_remove_from_leaf(n, idx);
		} else {
			mapnode_remove_from_non_leaf(n, idx);
		}
		return true;
	} else {
		if (isnil(n->children)) {
			return false;
		}
		bool flag = (idx == n->size ? true : false);
		if ((((mapnode*)(n->children[idx])))->size < _const_degree) {
			mapnode_fill(n, idx);
		}
		if (flag && idx > n->size) {
			return mapnode_remove_key((((mapnode*)(n->children[idx - 1]))), k);
		} else {
			return mapnode_remove_key((((mapnode*)(n->children[idx]))), k);
		}
	}
}

void mapnode_remove_from_leaf(mapnode* n, int idx) {
	for (int i = idx + 1;
	i < n->size; i++) {
		n->keys[i - 1] = n->keys[i];
		n->values[i - 1] = n->values[i];
	}
	n->size--;
}

void mapnode_remove_from_non_leaf(mapnode* n, int idx) {
	string k = n->keys[idx];
	if (((mapnode*)(n->children[idx]))->size >= _const_degree) {
		mapnode* current = ((mapnode*)(n->children[idx]));
		while (!isnil(current->children)) {
			current = ((mapnode*)(current->children[current->size]));
		}
		string predecessor = current->keys[current->size - 1];
		n->keys[idx] = predecessor;
		n->values[idx] = current->values[current->size - 1];
		mapnode_remove_key((((mapnode*)(n->children[idx]))), predecessor);
	} else if (((mapnode*)(n->children[idx + 1]))->size >= _const_degree) {
		mapnode* current = ((mapnode*)(n->children[idx + 1]));
		while (!isnil(current->children)) {
			current = ((mapnode*)(current->children[0]));
		}
		string successor = current->keys[0];
		n->keys[idx] = successor;
		n->values[idx] = current->values[0];
		mapnode_remove_key((((mapnode*)(n->children[idx + 1]))), successor);
	} else {
		mapnode_merge(n, idx);
		mapnode_remove_key((((mapnode*)(n->children[idx]))), k);
	}
}

void mapnode_fill(mapnode* n, int idx) {
	if (idx != 0 && ((mapnode*)(n->children[idx - 1]))->size >= _const_degree) {
		mapnode_borrow_from_prev(n, idx);
	} else if (idx != n->size && ((mapnode*)(n->children[idx + 1]))->size >= _const_degree) {
		mapnode_borrow_from_next(n, idx);
	} else if (idx != n->size) {
		mapnode_merge(n, idx);
	} else {
		mapnode_merge(n, idx - 1);
	}
}

void mapnode_borrow_from_prev(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx - 1]));
	for (int i = child->size - 1;
	i >= 0; i--) {
		child->keys[i + 1] = child->keys[i];
		child->values[i + 1] = child->values[i];
	}
	if (!isnil(child->children)) {
		for (int i = child->size;
		i >= 0; i--) {
			child->children[i + 1] = child->children[i];
		}
	}
	child->keys[0] = n->keys[idx - 1];
	child->values[0] = n->values[idx - 1];
	if (!isnil(child->children)) {
		child->children[0] = sibling->children[sibling->size];
	}
	n->keys[idx - 1] = sibling->keys[sibling->size - 1];
	n->values[idx - 1] = sibling->values[sibling->size - 1];
	child->size++;
	sibling->size--;
}

void mapnode_borrow_from_next(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx + 1]));
	child->keys[child->size] = n->keys[idx];
	child->values[child->size] = n->values[idx];
	if (!isnil(child->children)) {
		child->children[child->size + 1] = sibling->children[0];
	}
	n->keys[idx] = sibling->keys[0];
	n->values[idx] = sibling->values[0];
	for (int i = 1;
	i < sibling->size; i++) {
		sibling->keys[i - 1] = sibling->keys[i];
		sibling->values[i - 1] = sibling->values[i];
	}
	if (!isnil(sibling->children)) {
		for (int i = 1;
		i <= sibling->size; i++) {
			sibling->children[i - 1] = sibling->children[i];
		}
	}
	child->size++;
	sibling->size--;
}

void mapnode_merge(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx + 1]));
	child->keys[_const_mid_index] = n->keys[idx];
	child->values[_const_mid_index] = n->values[idx];
	for (int tmp1 = 0; tmp1 < sibling->size; tmp1++) {
		int i = tmp1;
		child->keys[i + _const_degree] = sibling->keys[i];
		child->values[i + _const_degree] = sibling->values[i];
	}
	if (!isnil(child->children)) {
		for (int i = 0;
		i <= sibling->size; i++) {
			child->children[i + _const_degree] = sibling->children[i];
		}
	}
	for (int i = idx + 1;
	i < n->size; i++) {
		n->keys[i - 1] = n->keys[i];
		n->values[i - 1] = n->values[i];
	}
	for (int i = idx + 2;
	i <= n->size; i++) {
		n->children[i - 1] = n->children[i];
	}
	child->size += sibling->size + 1;
	n->size--;
}

void SortedMap_delete(SortedMap* m, string key) {
	if (m->root->size == 0) {
		return;
	}
	bool removed = mapnode_remove_key(m->root, key);
	if (removed) {
		m->size--;
	}
	if (m->root->size == 0) {
		if (isnil(m->root->children)) {
			return;
		} else {
			m->root = ((mapnode*)(m->root->children[0]));
		}
	}
}

int mapnode_subkeys(mapnode* n, array_string* keys, int at) {
	int position = at;
	if (!isnil(n->children)) {
		for (int tmp2 = 0; tmp2 < n->size; tmp2++) {
			int i = tmp2;
			mapnode* child = ((mapnode*)(n->children[i]));
			position += mapnode_subkeys(child, keys, position);
			array_set(keys, position, &(string[]) { n->keys[i] });
			position++;
		}
		mapnode* child = ((mapnode*)(n->children[n->size]));
		position += mapnode_subkeys(child, keys, position);
	} else {
		for (int tmp3 = 0; tmp3 < n->size; tmp3++) {
			int i = tmp3;
			array_set(keys, position + i, &(string[]) { n->keys[i] });
		}
		position += n->size;
	}
	return position - at;
}

array_string SortedMap_keys(SortedMap* m) {
	array_string keys = array_repeat(new_array_from_c_array(1, 1, sizeof(string), (string[1]){
		tos3(""), 
}), m->size);
	if (isnil(m->root) || m->root->size == 0) {
		return keys;
	}
	mapnode_subkeys(m->root, &/*111*/(array[]){keys}[0], 0);
	return keys;
}

void mapnode_free(mapnode* n) {
	println(tos3("TODO"));
}

void SortedMap_free(SortedMap* m) {
	if (isnil(m->root)) {
		return;
	}
	mapnode_free(m->root);
}

void SortedMap_print(SortedMap m) {
	println(tos3("TODO"));
}

int vstrlen(byteptr s) {
	return strlen(((charptr)(s)));
}

string tos(byteptr s, int len) {
	if (s == 0) {
		v_panic(tos3("tos(): nil string"));
	}
	return (string){
		.str = s,
		.len = len,
	};
}

string tos_clone(byteptr s) {
	if (s == 0) {
		v_panic(tos3("tos: nil string"));
	}
	return string_clone(tos2(s));
}

string tos2(byteptr s) {
	if (s == 0) {
		v_panic(tos3("tos2: nil string"));
	}
	return (string){
		.str = s,
		.len = vstrlen(s),
	};
}

string tos3(charptr s) {
	if (s == 0) {
		v_panic(tos3("tos3: nil string"));
	}
	return (string){
		.str = ((byteptr)(s)),
		.len = strlen(s),
	};
}

string string_clone(string a) {
	string b = (string){
		.len = a.len,
		.str = v_malloc(a.len + 1),
	};
	for (int tmp1 = 0; tmp1 < a.len; tmp1++) {
		int i = tmp1;
		b.str[i] = a.str[i];
	}
	b.str[a.len] = '\0';
	return b;
}

string cstring_to_vstring(byteptr cstr) {
	int slen = strlen(cstr);
	byteptr s = ((byteptr)(memdup(cstr, slen + 1)));
	s[slen] = '\0';
	return tos(s, slen);
}

string string_replace_once(string s, string rep, string with) {
	Option_int index = string_index(s, rep);
	if (!index.ok) {
		string err = index.v_error;
		int errcode = index.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return s;
	};
	return string_add(string_add(string_substr(s, 0, /*opt*/(*(int*)index.data)), with), string_substr(s, /*opt*/(*(int*)index.data) + rep.len, s.len));
}

string string_replace(string s, string rep, string with) {
	if (s.len == 0 || rep.len == 0) {
		return s;
	}
	array_int idxs = new_array(0, 0, sizeof(int));
	int idx = 0;
	while (1) {
		idx = string_index_after(s, rep, idx);
		if (idx == -1) {
			break;
		}
		_PUSH(&idxs, (idx), tmp3, int);
		idx += rep.len;
	}
	if (idxs.len == 0) {
		return s;
	}
	int new_len = s.len + idxs.len * (with.len - rep.len);
	byteptr b = v_malloc(new_len + 1);
	int idx_pos = 0;
	int cur_idx = (*(int*)array_get(idxs, idx_pos));
	int b_i = 0;
	for (int i = 0;
	i < s.len; i++) {
		if (i == cur_idx) {
			for (int tmp6 = 0; tmp6 < with.len; tmp6++) {
				int j = tmp6;
				b[b_i] = string_at(with, j);
				b_i++;
			}
			i += rep.len - 1;
			idx_pos++;
			if (idx_pos < idxs.len) {
				cur_idx = (*(int*)array_get(idxs, idx_pos));
			}
		} else {
			b[b_i] = string_at(s, i);
			b_i++;
		}
	}
	b[new_len] = '\0';
	return tos(b, new_len);
}

int compare_rep_index(RepIndex* a, RepIndex* b) {
	if (a->idx < b->idx) {
		return -1;
	}
	if (a->idx > b->idx) {
		return 1;
	}
	return 0;
}

void array_RepIndex_sort(array_RepIndex* a) {
	array_sort_with_compare(a, &/*qq*/compare_rep_index);
}

string string_replace_each(string s, array_string vals) {
	if (s.len == 0 || vals.len == 0) {
		return s;
	}
	if (vals.len % 2 != 0) {
		println(tos3("string.replace_many(): odd number of strings"));
		return s;
	}
	int new_len = s.len;
	array_RepIndex idxs = new_array(0, 0, sizeof(RepIndex));
	int idx = 0;
	for (int rep_i = 0;
	rep_i < vals.len; rep_i += 2) {
		string rep = (*(string*)array_get(vals, rep_i));
		string with = (*(string*)array_get(vals, rep_i + 1));
		while (1) {
			idx = string_index_after(s, rep, idx);
			if (idx == -1) {
				break;
			}
			_PUSH(&idxs, ((RepIndex){
				.idx = idx,
				.val_idx = rep_i,
			}), tmp4, RepIndex);
			idx++;
			new_len += with.len - rep.len;
		}
	}
	if (idxs.len == 0) {
		return s;
	}
	array_RepIndex_sort(&idxs);
	byteptr b = v_malloc(new_len + 1);
	int idx_pos = 0;
	RepIndex cur_idx = (*(RepIndex*)array_get(idxs, idx_pos));
	int b_i = 0;
	for (int i = 0;
	i < s.len; i++) {
		if (i == cur_idx.idx) {
			string rep = (*(string*)array_get(vals, cur_idx.val_idx));
			string with = (*(string*)array_get(vals, cur_idx.val_idx + 1));
			for (int tmp7 = 0; tmp7 < with.len; tmp7++) {
				int j = tmp7;
				b[b_i] = string_at(with, j);
				b_i++;
			}
			i += rep.len - 1;
			idx_pos++;
			if (idx_pos < idxs.len) {
				cur_idx = (*(RepIndex*)array_get(idxs, idx_pos));
			}
		} else {
			b[b_i] = s.str[i];
			b_i++;
		}
	}
	b[new_len] = '\0';
	return tos(b, new_len);
}

bool string_bool(string s) {
	return string_eq(s, tos3("true")) || string_eq(s, tos3("t"));
}

int string_int(string s) {
	return ((int)(strconv__common_parse_int(s, 0, 32, false, false)));
}

i64 string_i64(string s) {
	return strconv__common_parse_int(s, 0, 64, false, false);
}

i8 string_i8(string s) {
	return ((i8)(strconv__common_parse_int(s, 0, 8, false, false)));
}

i16 string_i16(string s) {
	return ((i16)(strconv__common_parse_int(s, 0, 16, false, false)));
}

f32 string_f32(string s) {
	return ((f32)(strconv__atof64(s)));
}

f64 string_f64(string s) {
	return strconv__atof64(s);
}

u16 string_u16(string s) {
	return ((u16)(strconv__common_parse_uint(s, 0, 16, false, false)));
}

u32 string_u32(string s) {
	return ((u32)(strconv__common_parse_uint(s, 0, 32, false, false)));
}

u64 string_u64(string s) {
	return strconv__common_parse_uint(s, 0, 64, false, false);
}

bool string_eq(string s, string a) {
	if (isnil(s.str)) {
		v_panic(tos3("string.eq(): nil string"));
	}
	if (s.len != a.len) {
		return false;
	}
	for (int tmp3 = 0; tmp3 < s.len; tmp3++) {
		int i = tmp3;
		if (string_at(s, i) != string_at(a, i)) {
			return false;
		}
	}
	return true;
}

bool string_ne(string s, string a) {
	return !string_eq(s, a);
}

bool string_lt(string s, string a) {
	for (int tmp1 = 0; tmp1 < s.len; tmp1++) {
		int i = tmp1;
		if (i >= a.len || string_at(s, i) > string_at(a, i)) {
			return false;
		} else if (string_at(s, i) < string_at(a, i)) {
			return true;
		}
	}
	if (s.len < a.len) {
		return true;
	}
	return false;
}

bool string_le(string s, string a) {
	return string_lt(s, a) || string_eq(s, a);
}

bool string_gt(string s, string a) {
	return !string_le(s, a);
}

bool string_ge(string s, string a) {
	return !string_lt(s, a);
}

string string_add(string s, string a) {
	int new_len = a.len + s.len;
	string res = (string){
		.len = new_len,
		.str = v_malloc(new_len + 1),
	};
	for (int tmp1 = 0; tmp1 < s.len; tmp1++) {
		int j = tmp1;
		res.str[j] = s.str[j];
	}
	for (int tmp2 = 0; tmp2 < a.len; tmp2++) {
		int j = tmp2;
		res.str[s.len + j] = a.str[j];
	}
	res.str[new_len] = '\0';
	return res;
}

array_string string_split(string s, string delim) {
	return string_split_nth(s, delim, 0);
}

array_string string_split_nth(string s, string delim, int nth) {
	array_string res = new_array(0, 0, sizeof(string));
	int i = 0;
	if (delim.len == 0) {
		i = 1;
		for (int tmp2 = 0; tmp2 < s.len; tmp2++) {
		byte ch = s.str[tmp2];
			if (nth > 0 && i >= nth) {
				_PUSH(&res, (string_substr(s, i, s.len)), tmp4, string);
				break;
			}
			_PUSH(&res, (byte_str(ch)), tmp5, string);
			i++;
		}
		return res;
	}
	int start = 0;
	int nth_1 = nth - 1;
	while (i <= s.len) {
		bool is_delim = s.str[i] == delim.str[0];
		int j = 0;
		while (is_delim && j < delim.len) {
			is_delim = is_delim && s.str[i + j] == delim.str[j];
			j++;
		}
		bool last = i == s.len - 1;
		if (is_delim || last) {
			if (!is_delim && last) {
				i++;
			}
			string val = string_substr(s, start, i);
			if (string_starts_with(val, delim)) {
				val = string_right(val, delim.len);
			}
			bool was_last = nth > 0 && res.len == nth_1;
			if (was_last) {
				_PUSH(&res, (string_right(s, start)), tmp10, string);
				break;
			}
			_PUSH(&res, (val), tmp11, string);
			start = i + delim.len;
		}
		i++;
	}
	if (string_ends_with(s, delim) && (nth < 1 || res.len < nth)) {
		_PUSH(&res, (tos3("")), tmp13, string);
	}
	return res;
}

array_string string_split_into_lines(string s) {
	array_string res = new_array(0, 0, sizeof(string));
	if (s.len == 0) {
		return res;
	}
	int start = 0;
	for (int i = 0;
	i < s.len; i++) {
		bool is_lf = s.str[i] == '\n';
		bool is_crlf = i != s.len - 1 && s.str[i] == '\r' && s.str[i + 1] == '\n';
		bool is_eol = is_lf || is_crlf;
		bool is_last = (is_crlf ? i == s.len - 2 : i == s.len - 1);
		if (is_eol || is_last) {
			if (is_last && !is_eol) {
				i++;
			}
			string line = string_substr(s, start, i);
			_PUSH(&res, (line), tmp5, string);
			if (is_crlf) {
				i++;
			}
			start = i + 1;
		}
	}
	return res;
}

string string_left(string s, int n) {
	if (n >= s.len) {
		return s;
	}
	return string_substr(s, 0, n);
}

string string_right(string s, int n) {
	if (n >= s.len) {
		return tos3("");
	}
	return string_substr(s, n, s.len);
}

string string_substr2(string s, int start, int _end, bool end_max) {
	int end = (end_max ? s.len : _end);
	return string_substr(s, start, end);
}

string string_substr(string s, int start, int end) {
	
#ifndef NO_BOUNDS_CHECK
	// #if not no_bounds_checking
		if (start > end || start > s.len || end > s.len || start < 0 || end < 0) {
			v_panic(_STR("substr(%d, %d) out of bounds (len=%d)", start, end, s.len));
		}
	
#endif
	int len = end - start;
	string res = (string){
		.len = len,
		.str = v_malloc(len + 1),
	};
	for (int tmp2 = 0; tmp2 < len; tmp2++) {
		int i = tmp2;
		res.str[i] = s.str[start + i];
	}
	res.str[len] = '\0';
	return res;
}

int string_index_old(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return -1;
	}
	int i = 0;
	while (i < s.len) {
		int j = 0;
		while (j < p.len && s.str[i + j] == p.str[j]) {
			j++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

Option_int string_index(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return opt_none();
	}
	int i = 0;
	while (i < s.len) {
		int j = 0;
		while (j < p.len && s.str[i + j] == p.str[j]) {
			j++;
		}
		if (j == p.len) {
			return /*:)int*/opt_ok(&(int []) { i }, sizeof(int));
		}
		i++;
	}
	return opt_none();
}

int string_index_kmp(string s, string p) {
	if (p.len > s.len) {
		return -1;
	}
	array_int prefix = array_repeat(new_array_from_c_array(1, 1, sizeof(int), (int[1]){
		0, 
}), p.len);
	int j = 0;
	for (int i = 1;
	i < p.len; i++) {
		while (p.str[j] != p.str[i] && j > 0) {
			j = (*(int*)array_get(prefix, j - 1));
		}
		if (p.str[j] == p.str[i]) {
			j++;
		}
		array_set(&prefix, i, &(int[]) { j });
	}
	j = 0;
	for (int tmp3 = 0; tmp3 < s.len; tmp3++) {
		int i = tmp3;
		while (p.str[j] != s.str[i] && j > 0) {
			j = (*(int*)array_get(prefix, j - 1));
		}
		if (p.str[j] == s.str[i]) {
			j++;
		}
		if (j == p.len) {
			return i - p.len + 1;
		}
	}
	return -1;
}

int string_index_any(string s, string chars) {
	for (int tmp1 = 0; tmp1 < chars.len; tmp1++) {
	byte c = chars.str[tmp1];
		Option_int index = string_index(s, byte_str(c));
		if (!index.ok) {
			string err = index.v_error;
			int errcode = index.ecode;
			// last_type: v.ast.BranchStmt
			// last_expr_result_type: 
			continue;
		};
		return /*opt*/(*(int*)index.data);
	}
	return -1;
}

Option_int string_last_index(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return opt_none();
	}
	int i = s.len - p.len;
	while (i >= 0) {
		int j = 0;
		while (j < p.len && s.str[i + j] == p.str[j]) {
			j++;
		}
		if (j == p.len) {
			return /*:)int*/opt_ok(&(int []) { i }, sizeof(int));
		}
		i--;
	}
	return opt_none();
}

int string_index_after(string s, string p, int start) {
	if (p.len > s.len) {
		return -1;
	}
	int strt = start;
	if (start < 0) {
		strt = 0;
	}
	if (start >= s.len) {
		return -1;
	}
	int i = strt;
	while (i < s.len) {
		int j = 0;
		int ii = i;
		while (j < p.len && s.str[ii] == p.str[j]) {
			j++;
			ii++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

int string_index_byte(string s, byte c) {
	for (int tmp1 = 0; tmp1 < s.len; tmp1++) {
		int i = tmp1;
		if (s.str[i] == c) {
			return i;
		}
	}
	return -1;
}

int string_last_index_byte(string s, byte c) {
	for (int i = s.len - 1;
	i >= 0; i--) {
		if (s.str[i] == c) {
			return i;
		}
	}
	return -1;
}

int string_count(string s, string substr) {
	if (s.len == 0 || substr.len == 0) {
		return 0;
	}
	if (substr.len > s.len) {
		return 0;
	}
	int n = 0;
	int i = 0;
	while (1) {
		i = string_index_after(s, substr, i);
		if (i == -1) {
			return n;
		}
		i += substr.len;
		n++;
	}
	return 0;
}

bool string_contains(string s, string p) {
	Option_int tmp1 = string_index(s, p);
	if (!tmp1.ok) {
		string err = tmp1.v_error;
		int errcode = tmp1.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return false;
	};
	return true;
}

bool string_starts_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	}
	for (int tmp2 = 0; tmp2 < p.len; tmp2++) {
		int i = tmp2;
		if (s.str[i] != p.str[i]) {
			return false;
		}
	}
	return true;
}

bool string_ends_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	}
	for (int tmp2 = 0; tmp2 < p.len; tmp2++) {
		int i = tmp2;
		if (string_at(p, i) != string_at(s, s.len - p.len + i)) {
			return false;
		}
	}
	return true;
}

string string_to_lower(string s) {
	byteptr b = v_malloc(s.len + 1);
	for (int tmp1 = 0; tmp1 < s.len; tmp1++) {
		int i = tmp1;
		b[i] = tolower(s.str[i]);
	}
	return tos(b, s.len);
}

string string_to_upper(string s) {
	byteptr b = v_malloc(s.len + 1);
	for (int tmp1 = 0; tmp1 < s.len; tmp1++) {
		int i = tmp1;
		b[i] = toupper(s.str[i]);
	}
	return tos(b, s.len);
}

string string_capitalize(string s) {
	if (s.len == 0) {
		return tos3("");
	}
	string sl = string_to_lower(s);
	string cap = string_add(string_to_upper(byte_str(string_at(sl, 0))), string_right(sl, 1));
	return cap;
}

string string_title(string s) {
	array_string words = string_split(s, tos3(" "));
	array_string tit = new_array(0, 0, sizeof(string));
	// FOR IN
	for (int tmp1 = 0; tmp1 < words.
	len; tmp1++) {	string word = ((string*)words.
	data)[tmp1];_PUSH(&tit, (string_capitalize(word)), tmp2, string);
	}
	string title = array_string_join(tit, tos3(" "));
	return title;
}

string string_find_between(string s, string start, string end) {
	Option_int start_pos = string_index(s, start);
	if (!start_pos.ok) {
		string err = start_pos.v_error;
		int errcode = start_pos.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return tos3("");
	};
	string val = string_right(s, /*opt*/(*(int*)start_pos.data) + start.len);
	Option_int end_pos = string_index(val, end);
	if (!end_pos.ok) {
		string err = end_pos.v_error;
		int errcode = end_pos.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return val;
	};
	return string_left(val, /*opt*/(*(int*)end_pos.data));
}

bool array_string_contains(array_string ar, string val) {
	// FOR IN
	for (int tmp1 = 0; tmp1 < ar.
	len; tmp1++) {	string s = ((string*)ar.
	data)[tmp1];if (string_eq(s, val)) {
			return true;
		}
	}
	return false;
}

bool array_int_contains(array_int ar, int val) {
	// FOR IN
	for (int i = 0; i < ar.
	len; i++) {	int s = ((int*)ar.
	data)[i];if (s == val) {
			return true;
		}
	}
	return false;
}

bool byte_is_space(byte c) {
	return (c == ' ' || c == '\n' || c == '\t' || c == '\v' || c == '\f' || c == '\r' || c == 0x85 || c == 0xa0);
}

string string_trim_space(string s) {
	return string_trim(s, tos3(" \n\t\v\f\r"));
}

string string_trim(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return s;
	}
	array_byte cs_arr = string_bytes(cutset);
	int pos_left = 0;
	int pos_right = s.len - 1;
	bool cs_match = true;
	while (pos_left <= s.len && pos_right >= -1 && cs_match) {
		cs_match = false;
		if (_IN(byte, string_at(s, pos_left), cs_arr)) {
			pos_left++;
			cs_match = true;
		}
		if (_IN(byte, string_at(s, pos_right), cs_arr)) {
			pos_right--;
			cs_match = true;
		}
		if (pos_left > pos_right) {
			return tos3("");
		}
	}
	return string_substr(s, pos_left, pos_right + 1);
}

string string_trim_left(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return s;
	}
	array_byte cs_arr = string_bytes(cutset);
	int pos = 0;
	while (pos < s.len && _IN(byte, string_at(s, pos), cs_arr)) {
		pos++;
	}
	return string_right(s, pos);
}

string string_trim_right(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return s;
	}
	array_byte cs_arr = string_bytes(cutset);
	int pos = s.len - 1;
	while (pos >= 0 && _IN(byte, string_at(s, pos), cs_arr)) {
		pos--;
	}
	return (pos < 0 ? tos3("") : string_left(s, pos + 1));
}

int compare_strings(string* a, string* b) {
	if (string_lt(/*rec*/*a, */*d*/b)) {
		return -1;
	}
	if (string_gt(/*rec*/*a, */*d*/b)) {
		return 1;
	}
	return 0;
}

int compare_strings_by_len(string* a, string* b) {
	if (a->len < b->len) {
		return -1;
	}
	if (a->len > b->len) {
		return 1;
	}
	return 0;
}

int compare_lower_strings(string* a, string* b) {
	string aa = string_to_lower(/*rec*/*a);
	string bb = string_to_lower(/*rec*/*b);
	return compare_strings(&/*qq*/aa, &/*qq*/bb);
}

void array_string_sort(array_string* s) {
	array_sort_with_compare(s, &/*qq*/compare_strings);
}

void array_string_sort_ignore_case(array_string* s) {
	array_sort_with_compare(s, &/*qq*/compare_lower_strings);
}

void array_string_sort_by_len(array_string* s) {
	array_sort_with_compare(s, &/*qq*/compare_strings_by_len);
}

string ustring_str(ustring s) {
	return s.s;
}

ustring string_ustring(string s) {
	ustring res = (ustring){
		.s = s,
		.runes = new_array(0, s.len, sizeof(int)),
		.len = 0,
	};
	for (int i = 0;
	i < s.len; i++) {
		int char_len = utf8_char_len(s.str[i]);
		_PUSH(&res.runes, (i), tmp1, int);
		i += char_len - 1;
		res.len++;
	}
	return res;
}

ustring string_ustring_tmp(string s) {
	if (g_ustring_runes.len == 0) {
		g_ustring_runes = new_array(0, 128, sizeof(int));
	}
	ustring res = (ustring){
		.s = s,
		.runes = new_array(0, 1, sizeof(int)),
		.len = 0,
	};
	res.runes = g_ustring_runes;
	res.runes.len = s.len;
	int j = 0;
	for (int i = 0;
	i < s.len; i++) {
		int char_len = utf8_char_len(s.str[i]);
		(*(int*)array_get(res.runes, j)) = i;
		j++;
		i += char_len - 1;
		res.len++;
	}
	return res;
}

bool ustring_eq(ustring u, ustring a) {
	if (u.len != a.len || string_ne(u.s, a.s)) {
		return false;
	}
	return true;
}

bool ustring_ne(ustring u, ustring a) {
	return !ustring_eq(u, a);
}

bool ustring_lt(ustring u, ustring a) {
	return string_lt(u.s, a.s);
}

bool ustring_le(ustring u, ustring a) {
	return ustring_lt(u, a) || ustring_eq(u, a);
}

bool ustring_gt(ustring u, ustring a) {
	return !ustring_le(u, a);
}

bool ustring_ge(ustring u, ustring a) {
	return !ustring_lt(u, a);
}

ustring ustring_add(ustring u, ustring a) {
	ustring res = (ustring){
		.s = string_add(u.s, a.s),
		.runes = new_array(0, u.s.len + a.s.len, sizeof(int)),
		.len = 0,
	};
	int j = 0;
	for (int i = 0;
	i < u.s.len; i++) {
		int char_len = utf8_char_len(u.s.str[i]);
		_PUSH(&res.runes, (j), tmp1, int);
		i += char_len - 1;
		j += char_len;
		res.len++;
	}
	for (int i = 0;
	i < a.s.len; i++) {
		int char_len = utf8_char_len(a.s.str[i]);
		_PUSH(&res.runes, (j), tmp2, int);
		i += char_len - 1;
		j += char_len;
		res.len++;
	}
	return res;
}

int ustring_index_after(ustring u, ustring p, int start) {
	if (p.len > u.len) {
		return -1;
	}
	int strt = start;
	if (start < 0) {
		strt = 0;
	}
	if (start > u.len) {
		return -1;
	}
	int i = strt;
	while (i < u.len) {
		int j = 0;
		int ii = i;
		while (j < p.len && string_eq(ustring_at(u, ii), ustring_at(p, j))) {
			j++;
			ii++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

int ustring_count(ustring u, ustring substr) {
	if (u.len == 0 || substr.len == 0) {
		return 0;
	}
	if (substr.len > u.len) {
		return 0;
	}
	int n = 0;
	int i = 0;
	while (1) {
		i = ustring_index_after(u, substr, i);
		if (i == -1) {
			return n;
		}
		i += substr.len;
		n++;
	}
	return 0;
}

string ustring_substr(ustring u, int _start, int _end) {
	
#ifndef NO_BOUNDS_CHECK
	// #if not no_bounds_checking
		if (_start > _end || _start > u.len || _end > u.len || _start < 0 || _end < 0) {
			v_panic(_STR("substr(%d, %d) out of bounds (len=%d)", _start, _end, u.len));
		}
	
#endif
	int end = (_end >= u.len ? u.s.len : (*(int*)array_get(u.runes, _end)));
	return string_substr(u.s, (*(int*)array_get(u.runes, _start)), end);
}

string ustring_left(ustring u, int pos) {
	if (pos >= u.len) {
		return u.s;
	}
	return ustring_substr(u, 0, pos);
}

string ustring_right(ustring u, int pos) {
	if (pos >= u.len) {
		return tos3("");
	}
	return ustring_substr(u, pos, u.len);
}

byte string_at(string s, int idx) {
	
#ifndef NO_BOUNDS_CHECK
	// #if not no_bounds_checking
		if (idx < 0 || idx >= s.len) {
			v_panic(_STR("string index out of range: %d / %d", idx, s.len));
		}
	
#endif
	return s.str[idx];
}

string ustring_at(ustring u, int idx) {
	
#ifndef NO_BOUNDS_CHECK
	// #if not no_bounds_checking
		if (idx < 0 || idx >= u.len) {
			v_panic(_STR("string index out of range: %d / %d", idx, u.runes.len));
		}
	
#endif
	return ustring_substr(u, idx, idx + 1);
}

void ustring_free(ustring u) {
	array_free(u.runes);
}

bool byte_is_digit(byte c) {
	return c >= '0' && c <= '9';
}

bool byte_is_hex_digit(byte c) {
	return byte_is_digit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}

bool byte_is_oct_digit(byte c) {
	return c >= '0' && c <= '7';
}

bool byte_is_bin_digit(byte c) {
	return c == '0' || c == '1';
}

bool byte_is_letter(byte c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

void string_free(string s) {
	v_free(s.str);
}

string string_all_before(string s, string dot) {
	Option_int pos = string_index(s, dot);
	if (!pos.ok) {
		string err = pos.v_error;
		int errcode = pos.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return s;
	};
	return string_left(s, /*opt*/(*(int*)pos.data));
}

string string_all_before_last(string s, string dot) {
	Option_int pos = string_last_index(s, dot);
	if (!pos.ok) {
		string err = pos.v_error;
		int errcode = pos.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return s;
	};
	return string_left(s, /*opt*/(*(int*)pos.data));
}

string string_all_after(string s, string dot) {
	Option_int pos = string_last_index(s, dot);
	if (!pos.ok) {
		string err = pos.v_error;
		int errcode = pos.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return s;
	};
	return string_right(s, /*opt*/(*(int*)pos.data) + dot.len);
}

string string_after(string s, string dot) {
	return string_all_after(s, dot);
}

string array_string_join(array_string a, string del) {
	if (a.len == 0) {
		return tos3("");
	}
	int len = 0;
	// FOR IN
	for (int i = 0; i < a.
	len; i++) {	string val = ((string*)a.
	data)[i];len += val.len + del.len;
	}
	len -= del.len;
	string res = tos3("");
	res.len = len;
	res.str = v_malloc(res.len + 1);
	int idx = 0;
	// FOR IN
	for (int i = 0; i < a.
	len; i++) {	string val = ((string*)a.
	data)[i];for (int tmp2 = 0; tmp2 < val.len; tmp2++) {
			int j = tmp2;
			byte c = string_at(val, j);
			res.str[idx] = val.str[j];
			idx++;
		}
		if (i != a.len - 1) {
			for (int tmp4 = 0; tmp4 < del.len; tmp4++) {
				int k = tmp4;
				res.str[idx] = del.str[k];
				idx++;
			}
		}
	}
	res.str[res.len] = '\0';
	return res;
}

string array_string_join_lines(array_string s) {
	return array_string_join(s, tos3("\n"));
}

string string_reverse(string s) {
	if (s.len == 0 || s.len == 1) {
		return s;
	}
	string res = (string){
		.len = s.len,
		.str = v_malloc(s.len),
	};
	for (int i = s.len - 1;
	i >= 0; i--) {
		res.str[s.len - i - 1] = string_at(s, i);
	}
	return res;
}

string string_limit(string s, int max) {
	ustring u = string_ustring(s);
	if (u.len <= max) {
		return s;
	}
	return ustring_substr(u, 0, max);
}

//[deprecated]
bool byte_is_white(byte c) {
	v_panic(tos3("Use `string.is_space` instead of `string.is_white"));
}

int string_hash(string s) {
	int h = 0;
	if (h == 0 && s.len > 0) {
		for (int tmp2 = 0; tmp2 < s.len; tmp2++) {
		byte c = s.str[tmp2];
			h = h * 31 + ((int)(c));
		}
	}
	return h;
}

array_byte string_bytes(string s) {
	if (s.len == 0) {
		return new_array(0, 0, sizeof(byte));
	}
	array_byte buf = array_repeat(new_array_from_c_array(1, 1, sizeof(byte), (byte[1]){
		((byte)(0)), 
}), s.len);
	memcpy(buf.data, s.str, s.len);
	return buf;
}

string string_repeat(string s, int count) {
	if (count < 0) {
		v_panic(_STR("string.repeat: count is negative: %d", count));
	} else if (count == 0) {
		return tos3("");
	} else if (count == 1) {
		return s;
	}
	byteptr ret = v_malloc(s.len * count + 1);
	for (int tmp2 = 0; tmp2 < count; tmp2++) {
		int i = tmp2;
		for (int tmp3 = 0; tmp3 < s.len; tmp3++) {
			int j = tmp3;
			ret[i * s.len + j] = string_at(s, j);
		}
	}
	ret[s.len * count] = 0;
	return tos2(ret);
}

string string_strip_margin(string s) {
	return string_strip_margin_custom(s, '|');
}

string string_strip_margin_custom(string s, byte del) {
	byte sep = del;
	if (byte_is_space(sep)) {
		eprintln(tos3("Warning: `strip_margin` cannot use white-space as a delimiter"));
		eprintln(tos3("    Defaulting to `|`"));
		sep = '|';
	}
	byteptr ret = v_malloc(s.len + 1);
	int count = 0;
	for (int i = 0;
	i < s.len; i++) {
		if ((string_at(s, i) == '\n' || string_at(s, i) == '\r')) {
			ret[count] = string_at(s, i);
			count++;
			if (string_at(s, i) == '\r' && i < s.len - 1 && string_at(s, i + 1) == '\n') {
				ret[count] = string_at(s, i + 1);
				count++;
				i++;
			}
			while (string_at(s, i) != sep) {
				i++;
				if (i >= s.len) {
					break;
				}
			}
		} else {
			ret[count] = string_at(s, i);
			count++;
		}
	}
	ret[count] = 0;
	return tos2(ret);
}

int utf8_char_len(byte b) {
	return (((0xe5000000 >> (((b >> 3) & 0x1e))) & 3)) + 1;
}

string utf32_to_str(u32 code) {
	int icode = ((int)(code));
	byteptr buffer = v_malloc(5);
	if (icode <= 127) {
		buffer[0] = icode;
		return tos(buffer, 1);
	}
	if (icode <= 2047) {
		buffer[0] = (192 | (icode >> 6));
		buffer[1] = (128 | ((icode & 63)));
		return tos(buffer, 2);
	}
	if (icode <= 65535) {
		buffer[0] = (224 | (icode >> 12));
		buffer[1] = (128 | (((icode >> 6) & 63)));
		buffer[2] = (128 | ((icode & 63)));
		return tos(buffer, 3);
	}
	if (icode <= 1114111) {
		buffer[0] = (240 | (icode >> 18));
		buffer[1] = (128 | (((icode >> 12) & 63)));
		buffer[2] = (128 | (((icode >> 6) & 63)));
		buffer[3] = (128 | ((icode & 63)));
		return tos(buffer, 4);
	}
	return tos3("");
}

string utf32_to_str_no_malloc(u32 code, voidptr buf) {
	int icode = ((int)(code));
	byteptr buffer = ((byteptr)(buf));
	if (icode <= 127) {
		buffer[0] = icode;
		return tos(buffer, 1);
	}
	if (icode <= 2047) {
		buffer[0] = (192 | (icode >> 6));
		buffer[1] = (128 | ((icode & 63)));
		return tos(buffer, 2);
	}
	if (icode <= 65535) {
		buffer[0] = (224 | (icode >> 12));
		buffer[1] = (128 | (((icode >> 6) & 63)));
		buffer[2] = (128 | ((icode & 63)));
		return tos(buffer, 3);
	}
	if (icode <= 1114111) {
		buffer[0] = (240 | (icode >> 18));
		buffer[1] = (128 | (((icode >> 12) & 63)));
		buffer[2] = (128 | (((icode >> 6) & 63)));
		buffer[3] = (128 | ((icode & 63)));
		return tos(buffer, 4);
	}
	return tos3("");
}

int string_utf32_code(string _rune) {
	if (_rune.len == 0) {
		return 0;
	}
	if (_rune.len == 1) {
		return ((int)(string_at(_rune, 0)));
	}
	byte b = ((byte)(((int)(string_at(_rune, 0)))));
	b = b << _rune.len;
	int res = ((int)(b));
	int shift = 6 - _rune.len;
	for (int i = 1;
	i < _rune.len; i++) {
		int c = ((int)(string_at(_rune, i)));
		res = res << shift;
		res |= (c & 63);
		shift = 6;
	}
	return res;
}

u16* string_to_wide(string _str) {
	
#ifdef _WIN32
	// #if windows
		int num_chars = (MultiByteToWideChar(_const_CP_UTF8, 0, _str.str, _str.len, 0, 0));
		u16* wstr = ((u16*)(v_malloc((num_chars + 1) * 2)));
		if (!isnil(wstr)) {
			MultiByteToWideChar(_const_CP_UTF8, 0, _str.str, _str.len, wstr, num_chars);
			memset(((byte*)(wstr)) + num_chars * 2, 0, 2);
		}
		return wstr;
	
#else
		return 0;
	
#endif
}

string string_from_wide(u16* _wstr) {
	
#ifdef _WIN32
	// #if windows
		int wstr_len = wcslen(_wstr);
		return string_from_wide2(_wstr, wstr_len);
	
#else
		return tos3("");
	
#endif
}

string string_from_wide2(u16* _wstr, int len) {
	
#ifdef _WIN32
	// #if windows
		int num_chars = WideCharToMultiByte(_const_CP_UTF8, 0, _wstr, len, 0, 0, 0, 0);
		byteptr str_to = v_malloc(num_chars + 1);
		if (!isnil(str_to)) {
			WideCharToMultiByte(_const_CP_UTF8, 0, _wstr, len, str_to, num_chars, 0, 0);
			memset(str_to + num_chars, 0, 1);
		}
		return tos2(str_to);
	
#else
		return tos3("");
	
#endif
}

int utf8_len(byte c) {
	int b = 0;
	byte x = c;
	if (((x & 240)) != 0) {
		x >>= 4;
	} else {
		b += 4;
	}
	if (((x & 12)) != 0) {
		x >>= 2;
	} else {
		b += 2;
	}
	if (((x & 2)) == 0) {
		b++;
	}
	return b;
}

int utf8_getchar() {
	int c = getchar();
	int len = utf8_len(~c);
	if (c < 0) {
		return 0;
	} else if (len == 0) {
		return c;
	} else if (len == 1) {
		return -1;
	} else {
		int uc = (c & ((1 << (7 - len)) - 1));
		for (int i = 0;
		i + 1 < len; i++) {
			int c2 = getchar();
			if (c2 != -1 && (c2 >> 6) == 2) {
				uc <<= 6;
				uc |= ((c2 & 63));
			} else if (c2 == -1) {
				return 0;
			} else {
				return -1;
			}
		}
		return uc;
	}
}



string* generate_strings(int len, int amount) {
	byteptr mem = v_malloc(sizeof(string) * amount);
	string* arr = ((string*)(mem));
	for (int i = 0;
	i < amount - 1; i += 2) {
		byte* buf = ((byte*)(vcalloc(sizeof(byte) * (len + 1))));
		for (int tmp1 = 0; tmp1 < len; tmp1++) {
			int j = tmp1;
			buf[j] = ((byte)(rand__next(((int)('z')) - ((int)('a'))) + 'a'));
		}
		buf[len] = 0;
		string str = tos2(buf);
		arr[i] = str;
		arr[i + 1] = str;
	}
	return arr;
}

inline
bool fast_string_eq(string a, string b) {
	if (a.len != b.len) {
		return false;
	}
	return memcmp(a.str, b.str, b.len) == 0;
}

inline
bool fast_string_eq2(string a, string b) {
	if (a.len != b.len) {
		return false;
	}
	return strcmp(a.str, b.str) == 0;
}

int main(int ___argc, char** ___argv) {
	_vinit();
	int amount = 10000000;
	string* a = generate_strings(40, amount);
	int b = 0;
	i64 start_time = time__ticks();
	for (int tmp1 = 0; tmp1 < 100; tmp1++) {
		int _ = tmp1;
		for (int i = 0;
		i < amount - 1; i += 2) {
			if (fast_string_eq(a[i], a[i + 1])) {
				b++;
			}
		}
	}
	i64 end_time = time__ticks() - start_time;
	println(int_str(b));
	println(i64_str(end_time));
	return 0;
}

strings__Builder strings__new_builder(int initial_size) {
	return (strings__Builder){
		.buf = make(0, initial_size, 1),
		.initial_size = initial_size,
		.len = 0,
	};
}

void strings__Builder_write_bytes(strings__Builder* b, byteptr bytes, int howmany) {
	array_push_many(&b->buf, bytes, howmany);
	b->len += howmany;
}

void strings__Builder_write_b(strings__Builder* b, byte data) {
	_PUSH(&b->buf, (data), tmp1, byte);
	b->len++;
}

void strings__Builder_write(strings__Builder* b, string s) {
	if (string_eq(s, tos3(""))) {
		return;
	}
	array_push_many(&b->buf, s.str, s.len);
	b->len += s.len;
}

void strings__Builder_go_back(strings__Builder* b, int n) {
	array_trim(&b->buf, b->buf.len - n);
	b->len -= n;
}

void strings__Builder_writeln(strings__Builder* b, string s) {
	array_push_many(&b->buf, s.str, s.len);
	_PUSH(&b->buf, ('\n'), tmp1, byte);
	b->len += s.len + 1;
}

string strings__Builder_last_n(strings__Builder* b, int n) {
	if (n > b->len) {
		return tos3("");
	}
	array_byte buf = array_slice(b->buf, b->len - n, b->buf.len);
	return tos2(array_clone(&buf).data);
}

string strings__Builder_after(strings__Builder* b, int n) {
	if (n >= b->len) {
		return tos3("");
	}
	array_byte buf = array_slice(b->buf, n, b->buf.len);
	array_byte copy = array_clone(&buf);
	_PUSH(&copy, ('\0'), tmp2, byte);
	return tos2(copy.data);
}

string strings__Builder_str(strings__Builder* b) {
	_PUSH(&b->buf, ('\0'), tmp1, byte);
	return tos(b->buf.data, b->len);
}

void strings__Builder_free(strings__Builder* b) {
		v_free(b->buf.data);
	b->buf = make(0, b->initial_size, 1);
	b->len = 0;
}

int strings__levenshtein_distance(string a, string b) {
	array_int f = array_repeat(new_array_from_c_array(1, 1, sizeof(int), (int[1]){
		0, 
}), b.len + 1);
	for (int tmp1 = 0; tmp1 < f.len; tmp1++) {
		int j = tmp1;
		array_set(&f, j, &(int[]) { j });
	}
	for (int tmp2 = 0; tmp2 < a.len; tmp2++) {
	byte ca = a.str[tmp2];
		int j = 1;
		int fj1 = (*(int*)array_get(f, 0));
		(*(int*)array_get(f, 0))++;
		for (int tmp3 = 0; tmp3 < b.len; tmp3++) {
		byte cb = b.str[tmp3];
			int mn = ((*(int*)array_get(f, j)) + 1 <= (*(int*)array_get(f, j - 1)) + 1 ? (*(int*)array_get(f, j)) + 1 : (*(int*)array_get(f, j - 1)) + 1);
			if (cb != ca) {
				mn = (mn <= fj1 + 1 ? mn : fj1 + 1);
			} else {
				mn = (mn <= fj1 ? mn : fj1);
			}
			fj1 = (*(int*)array_get(f, j));
			array_set(&f, j, &(int[]) { mn });
			j++;
		}
	}
	return (*(int*)array_get(f, f.len - 1));
}

f32 strings__levenshtein_distance_percentage(string a, string b) {
	int d = strings__levenshtein_distance(a, b);
	int l = (a.len >= b.len ? a.len : b.len);
	return (1.00 - ((f32)(d)) / ((f32)(l))) * 100.00;
}

f32 strings__dice_coefficient(string s1, string s2) {
	if (s1.len == 0 || s2.len == 0) {
		return 0.0;
	}
	if (string_eq(s1, s2)) {
		return 1.0;
	}
	if (s1.len < 2 || s2.len < 2) {
		return 0.0;
	}
	string a = (s1.len > s2.len ? s1 : s2);
	string b = (string_eq(a, s1) ? s2 : s1);
	map_string_int first_bigrams = new_map(1, sizeof(int));
	for (int tmp6 = 0; tmp6 < a.len - 1; tmp6++) {
		int i = tmp6;
		string bigram = string_substr(a, i, i + 2);
		int q = (_IN_MAP(bigram, first_bigrams) ? (*(int*)map_get3(first_bigrams, bigram, &(int[]){ 0 })) + 1 : 1);
		map_set(&first_bigrams, bigram, &(int[]) { q });
	}
	int intersection_size = 0;
	for (int tmp8 = 0; tmp8 < b.len - 1; tmp8++) {
		int i = tmp8;
		string bigram = string_substr(b, i, i + 2);
		int count = (_IN_MAP(bigram, first_bigrams) ? (*(int*)map_get3(first_bigrams, bigram, &(int[]){ 0 })) : 0);
		if (count > 0) {
			map_set(&first_bigrams, bigram, &(int[]) { count - 1 });
			intersection_size++;
		}
	}
	return (2.0 * intersection_size) / (((f32)(a.len)) + ((f32)(b.len)) - 2);
}

string strings__repeat(byte c, int n) {
	if (n <= 0) {
		return tos3("");
	}
	byte* bytes = ((byte*)(0));
		bytes = v_malloc(n + 1);
	memset(bytes, c, n);
	bytes[n] = '0';
	return tos(bytes, n);
}

string strings__repeat_string(string s, int n) {
	if (n <= 0 || s.len == 0) {
		return tos3("");
	}
	int slen = s.len;
	int blen = slen * n;
	byte* bytes = ((byte*)(0));
		bytes = v_malloc(blen + 1);
	for (int tmp2 = 0; tmp2 < n; tmp2++) {
		int bi = tmp2;
		int bislen = bi * slen;
		for (int tmp3 = 0; tmp3 < slen; tmp3++) {
			int si = tmp3;
			bytes[bislen + si] = string_at(s, si);
		}
	}
	bytes[blen] = '0';
	return tos(bytes, blen);
}

string strconv__ftoa__Dec32_get_string_32(strconv__ftoa__Dec32 d, bool neg, int i_n_digit) {
	int n_digit = i_n_digit + 1;
	u32 out = d.m;
	int out_len = strconv__ftoa__decimal_len_32(out);
	int out_len_original = out_len;
	array_byte buf = array_repeat(new_array_from_c_array(1, 1, sizeof(byte), (byte[1]){
		((byte)(0)), 
}), out_len + 5 + 1 + 1);
	int i = 0;
	if (neg) {
		array_set(&buf, i, &(byte[]) { '-' });
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += (*(u32*)array_get(_const_strconv__ftoa__ten_pow_table_32, out_len - n_digit)) + 1;
		out /= (*(u32*)array_get(_const_strconv__ftoa__ten_pow_table_32, out_len - n_digit));
		out_len = n_digit;
	}
	int y = i + out_len;
	int x = 0;
	while (x < (out_len - disp - 1)) {
		array_set(&buf, y - x, &(byte[]) { '0' + ((byte)(out % 10)) });
		out /= 10;
		i++;
		x++;
	}
	if (out_len >= 1) {
		array_set(&buf, y - x, &(byte[]) { '.' });
		x++;
		i++;
	}
	if (y - x >= 0) {
		array_set(&buf, y - x, &(byte[]) { '0' + ((byte)(out % 10)) });
		i++;
	}
	array_set(&buf, i, &(byte[]) { 'e' });
	i++;
	int exp = d.e + out_len_original - 1;
	if (exp < 0) {
		array_set(&buf, i, &(byte[]) { '-' });
		i++;
		exp = -exp;
	} else {
		array_set(&buf, i, &(byte[]) { '+' });
		i++;
	}
	int d1 = exp % 10;
	int d0 = exp / 10;
	array_set(&buf, i, &(byte[]) { '0' + ((byte)(d0)) });
	i++;
	array_set(&buf, i, &(byte[]) { '0' + ((byte)(d1)) });
	i++;
	array_set(&buf, i, &(byte[]) { 0 });
	return tos(((byteptr)(&(*(byte*)array_get(buf, 0)))), i);
}

multi_return_strconv__ftoa__Dec32_bool strconv__ftoa__f32_to_decimal_exact_int(u32 i_mant, u32 exp) {
	strconv__ftoa__Dec32 d = (strconv__ftoa__Dec32){
		.m = 0,
		.e = 0,
	};
	u32 e = exp - _const_strconv__ftoa__bias32;
	if (e > _const_strconv__ftoa__mantbits32) {
		return (multi_return_strconv__ftoa__Dec32_bool){.arg0=d,.arg1=false};
	}
	u32 shift = _const_strconv__ftoa__mantbits32 - e;
	u32 mant = (i_mant | 0x00800000);
	d.m = mant >> shift;
	if ((d.m << shift) != mant) {
		return (multi_return_strconv__ftoa__Dec32_bool){.arg0=d,.arg1=false};
	}
	while ((d.m % 10) == 0) {
		d.m /= 10;
		d.e++;
	}
	return (multi_return_strconv__ftoa__Dec32_bool){.arg0=d,.arg1=true};
}

strconv__ftoa__Dec32 strconv__ftoa__f32_to_decimal(u32 mant, u32 exp) {
	int e2 = 0;
	u32 m2 = ((u32)(0));
	if (exp == 0) {
		e2 = 1 - _const_strconv__ftoa__bias32 - _const_strconv__ftoa__mantbits32 - 2;
		m2 = mant;
	} else {
		e2 = ((int)(exp)) - _const_strconv__ftoa__bias32 - _const_strconv__ftoa__mantbits32 - 2;
		m2 = ((((u32)(1)) << _const_strconv__ftoa__mantbits32) | mant);
	}
	bool even = ((m2 & 1)) == 0;
	bool accept_bounds = even;
	u32 mv = ((u32)(4 * m2));
	u32 mp = ((u32)(4 * m2 + 2));
	u32 mm_shift = strconv__ftoa__bool_to_u32(mant != 0 || exp <= 1);
	u32 mm = ((u32)(4 * m2 - 1 - mm_shift));
	u32 vr = ((u32)(0));
	u32 vp = ((u32)(0));
	u32 vm = ((u32)(0));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	byte last_removed_digit = ((byte)(0));
	if (e2 >= 0) {
		u32 q = strconv__ftoa__log10_pow2(e2);
		e10 = ((int)(q));
		int k = _const_strconv__ftoa__pow5_inv_num_bits_32 + strconv__ftoa__pow5_bits(((int)(q))) - 1;
		int i = -e2 + ((int)(q)) + k;
		vr = strconv__ftoa__mul_pow5_invdiv_pow2(mv, q, i);
		vp = strconv__ftoa__mul_pow5_invdiv_pow2(mp, q, i);
		vm = strconv__ftoa__mul_pow5_invdiv_pow2(mm, q, i);
		if (q != 0 && (vp - 1) / 10 <= vm / 10) {
			int l = _const_strconv__ftoa__pow5_inv_num_bits_32 + strconv__ftoa__pow5_bits(((int)(q - 1))) - 1;
			last_removed_digit = ((byte)(strconv__ftoa__mul_pow5_invdiv_pow2(mv, q - 1, -e2 + ((int)(q - 1)) + l) % 10));
		}
		if (q <= 9) {
			if (mv % 5 == 0) {
				vr_is_trailing_zeros = strconv__ftoa__multiple_of_power_of_five_32(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__ftoa__multiple_of_power_of_five_32(mm, q);
			} else if (strconv__ftoa__multiple_of_power_of_five_32(mp, q)) {
				vp--;
			}
		}
	} else {
		u32 q = strconv__ftoa__log10_pow5(-e2);
		e10 = ((int)(q)) + e2;
		int i = -e2 - ((int)(q));
		int k = strconv__ftoa__pow5_bits(i) - _const_strconv__ftoa__pow5_num_bits_32;
		int j = ((int)(q)) - k;
		vr = strconv__ftoa__mul_pow5_div_pow2(mv, ((u32)(i)), j);
		vp = strconv__ftoa__mul_pow5_div_pow2(mp, ((u32)(i)), j);
		vm = strconv__ftoa__mul_pow5_div_pow2(mm, ((u32)(i)), j);
		if (q != 0 && ((vp - 1) / 10) <= vm / 10) {
			j = ((int)(q)) - 1 - (strconv__ftoa__pow5_bits(i + 1) - _const_strconv__ftoa__pow5_num_bits_32);
			last_removed_digit = ((byte)(strconv__ftoa__mul_pow5_div_pow2(mv, ((u32)(i + 1)), j) % 10));
		}
		if (q <= 1) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = mm_shift == 1;
			} else {
				vp--;
			}
		} else if (q < 31) {
			vr_is_trailing_zeros = strconv__ftoa__multiple_of_power_of_two_32(mv, q - 1);
		}
	}
	int removed = 0;
	u32 out = ((u32)(0));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		while (vp / 10 > vm / 10) {
			vm_is_trailing_zeros = vm_is_trailing_zeros && (vm % 10) == 0;
			vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
			last_removed_digit = ((byte)(vr % 10));
			vr /= 10;
			vp /= 10;
			vm /= 10;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			while (vm % 10 == 0) {
				vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
				last_removed_digit = ((byte)(vr % 10));
				vr /= 10;
				vp /= 10;
				vm /= 10;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && (last_removed_digit == 5) && (vr % 2) == 0) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		while (vp / 10 > vm / 10) {
			last_removed_digit = ((byte)(vr % 10));
			vr /= 10;
			vp /= 10;
			vm /= 10;
			removed++;
		}
		out = vr + strconv__ftoa__bool_to_u32(vr == vm || last_removed_digit >= 5);
	}
	return (strconv__ftoa__Dec32){
		.m = out,
		.e = e10 + removed,
	};
}

string strconv__ftoa__f32_to_str(f32 f, int n_digit) {
	strconv__ftoa__Uf32 u1 = (strconv__ftoa__Uf32){
		.f = 0,
		.u = 0,
	};
	u1.f = f;
	u32 u = u1.u;
	bool neg = (u >> (_const_strconv__ftoa__mantbits32 + _const_strconv__ftoa__expbits32)) != 0;
	u32 mant = (u & ((((u32)(1)) << _const_strconv__ftoa__mantbits32) - ((u32)(1))));
	u32 exp = ((u >> _const_strconv__ftoa__mantbits32) & ((((u32)(1)) << _const_strconv__ftoa__expbits32) - ((u32)(1))));
	if ((exp == _const_strconv__ftoa__maxexp32) || (exp == 0 && mant == 0)) {
		return strconv__ftoa__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__ftoa__Dec32_bool mr_8266 = strconv__ftoa__f32_to_decimal_exact_int(mant, exp);
	strconv__ftoa__Dec32 d = mr_8266.arg0;
	bool ok = mr_8266.arg1;
	if (!ok) {
		d = strconv__ftoa__f32_to_decimal(mant, exp);
	}
	return strconv__ftoa__Dec32_get_string_32(d, neg, n_digit);
}

string strconv__ftoa__Dec64_get_string_64(strconv__ftoa__Dec64 d, bool neg, int i_n_digit) {
	int n_digit = i_n_digit + 1;
	u64 out = d.m;
	int out_len = strconv__ftoa__decimal_len_64(out);
	int out_len_original = out_len;
	array_byte buf = array_repeat(new_array_from_c_array(1, 1, sizeof(byte), (byte[1]){
		((byte)(0)), 
}), out_len + 6 + 1 + 1);
	int i = 0;
	if (neg) {
		array_set(&buf, i, &(byte[]) { '-' });
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += (*(u64*)array_get(_const_strconv__ftoa__ten_pow_table_64, out_len - n_digit)) + 1;
		out /= (*(u64*)array_get(_const_strconv__ftoa__ten_pow_table_64, out_len - n_digit));
		out_len = n_digit;
	}
	int y = i + out_len;
	int x = 0;
	while (x < (out_len - disp - 1)) {
		array_set(&buf, y - x, &(byte[]) { '0' + ((byte)(out % 10)) });
		out /= 10;
		i++;
		x++;
	}
	if (out_len >= 1) {
		array_set(&buf, y - x, &(byte[]) { '.' });
		x++;
		i++;
	}
	if (y - x >= 0) {
		array_set(&buf, y - x, &(byte[]) { '0' + ((byte)(out % 10)) });
		i++;
	}
	array_set(&buf, i, &(byte[]) { 'e' });
	i++;
	int exp = d.e + out_len_original - 1;
	if (exp < 0) {
		array_set(&buf, i, &(byte[]) { '-' });
		i++;
		exp = -exp;
	} else {
		array_set(&buf, i, &(byte[]) { '+' });
		i++;
	}
	int d2 = exp % 10;
	exp /= 10;
	int d1 = exp % 10;
	int d0 = exp / 10;
	if (d0 > 0) {
		array_set(&buf, i, &(byte[]) { '0' + ((byte)(d0)) });
		i++;
	}
	array_set(&buf, i, &(byte[]) { '0' + ((byte)(d1)) });
	i++;
	array_set(&buf, i, &(byte[]) { '0' + ((byte)(d2)) });
	i++;
	array_set(&buf, i, &(byte[]) { 0 });
	return tos(((byteptr)(&(*(byte*)array_get(buf, 0)))), i);
}

multi_return_strconv__ftoa__Dec64_bool strconv__ftoa__f64_to_decimal_exact_int(u64 i_mant, u64 exp) {
	strconv__ftoa__Dec64 d = (strconv__ftoa__Dec64){
		.m = 0,
		.e = 0,
	};
	u64 e = exp - _const_strconv__ftoa__bias64;
	if (e > _const_strconv__ftoa__mantbits64) {
		return (multi_return_strconv__ftoa__Dec64_bool){.arg0=d,.arg1=false};
	}
	u32 shift = _const_strconv__ftoa__mantbits64 - e;
	u64 mant = (i_mant | ((u64)(0x0010000000000000)));
	d.m = mant >> shift;
	if ((d.m << shift) != mant) {
		return (multi_return_strconv__ftoa__Dec64_bool){.arg0=d,.arg1=false};
	}
	while ((d.m % 10) == 0) {
		d.m /= 10;
		d.e++;
	}
	return (multi_return_strconv__ftoa__Dec64_bool){.arg0=d,.arg1=true};
}

strconv__ftoa__Dec64 strconv__ftoa__f64_to_decimal(u64 mant, u64 exp) {
	int e2 = 0;
	u64 m2 = ((u64)(0));
	if (exp == 0) {
		e2 = 1 - _const_strconv__ftoa__bias64 - _const_strconv__ftoa__mantbits64 - 2;
		m2 = mant;
	} else {
		e2 = ((int)(exp)) - _const_strconv__ftoa__bias64 - _const_strconv__ftoa__mantbits64 - 2;
		m2 = ((((u64)(1)) << _const_strconv__ftoa__mantbits64) | mant);
	}
	bool even = ((m2 & 1)) == 0;
	bool accept_bounds = even;
	u64 mv = ((u64)(4 * m2));
	u64 mm_shift = strconv__ftoa__bool_to_u64(mant != 0 || exp <= 1);
	u64 vr = ((u64)(0));
	u64 vp = ((u64)(0));
	u64 vm = ((u64)(0));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	if (e2 >= 0) {
		u32 q = strconv__ftoa__log10_pow2(e2) - strconv__ftoa__bool_to_u32(e2 > 3);
		e10 = ((int)(q));
		int k = _const_strconv__ftoa__pow5_inv_num_bits_64 + strconv__ftoa__pow5_bits(((int)(q))) - 1;
		int i = -e2 + ((int)(q)) + k;
		strconv__ftoa__Uint128 mul = (*(strconv__ftoa__Uint128*)array_get(_const_strconv__ftoa__pow5_inv_split_64, q));
		vr = strconv__ftoa__mul_shift_64(((u64)(4)) * m2, mul, i);
		vp = strconv__ftoa__mul_shift_64(((u64)(4)) * m2 + ((u64)(2)), mul, i);
		vm = strconv__ftoa__mul_shift_64(((u64)(4)) * m2 - ((u64)(1)) - mm_shift, mul, i);
		if (q <= 21) {
			if (mv % 5 == 0) {
				vr_is_trailing_zeros = strconv__ftoa__multiple_of_power_of_five_64(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__ftoa__multiple_of_power_of_five_64(mv - 1 - mm_shift, q);
			} else if (strconv__ftoa__multiple_of_power_of_five_64(mv + 2, q)) {
				vp--;
			}
		}
	} else {
		u32 q = strconv__ftoa__log10_pow5(-e2) - strconv__ftoa__bool_to_u32(-e2 > 1);
		e10 = ((int)(q)) + e2;
		int i = -e2 - ((int)(q));
		int k = strconv__ftoa__pow5_bits(i) - _const_strconv__ftoa__pow5_num_bits_64;
		int j = ((int)(q)) - k;
		strconv__ftoa__Uint128 mul = (*(strconv__ftoa__Uint128*)array_get(_const_strconv__ftoa__pow5_split_64, i));
		vr = strconv__ftoa__mul_shift_64(((u64)(4)) * m2, mul, j);
		vp = strconv__ftoa__mul_shift_64(((u64)(4)) * m2 + ((u64)(2)), mul, j);
		vm = strconv__ftoa__mul_shift_64(((u64)(4)) * m2 - ((u64)(1)) - mm_shift, mul, j);
		if (q <= 1) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = (mm_shift == 1);
			} else {
				vp--;
			}
		} else if (q < 63) {
			vr_is_trailing_zeros = strconv__ftoa__multiple_of_power_of_two_64(mv, q - 1);
		}
	}
	int removed = 0;
	byte last_removed_digit = ((byte)(0));
	u64 out = ((u64)(0));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		while (1) {
			u64 vp_div_10 = vp / 10;
			u64 vm_div_10 = vm / 10;
			if (vp_div_10 <= vm_div_10) {
				break;
			}
			u64 vm_mod_10 = vm % 10;
			u64 vr_div_10 = vr / 10;
			u64 vr_mod_10 = vr % 10;
			vm_is_trailing_zeros = vm_is_trailing_zeros && vm_mod_10 == 0;
			vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
			last_removed_digit = ((byte)(vr_mod_10));
			vr = vr_div_10;
			vp = vp_div_10;
			vm = vm_div_10;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			while (1) {
				u64 vm_div_10 = vm / 10;
				u64 vm_mod_10 = vm % 10;
				if (vm_mod_10 != 0) {
					break;
				}
				u64 vp_div_10 = vp / 10;
				u64 vr_div_10 = vr / 10;
				u64 vr_mod_10 = vr % 10;
				vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
				last_removed_digit = ((byte)(vr_mod_10));
				vr = vr_div_10;
				vp = vp_div_10;
				vm = vm_div_10;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && (last_removed_digit == 5) && (vr % 2) == 0) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		bool round_up = false;
		while (vp / 100 > vm / 100) {
			round_up = (vr % 100) >= 50;
			vr /= 100;
			vp /= 100;
			vm /= 100;
			removed += 2;
		}
		while (vp / 10 > vm / 10) {
			round_up = (vr % 10) >= 5;
			vr /= 10;
			vp /= 10;
			vm /= 10;
			removed++;
		}
		out = vr + strconv__ftoa__bool_to_u64(vr == vm || round_up);
	}
	return (strconv__ftoa__Dec64){
		.m = out,
		.e = e10 + removed,
	};
}

string strconv__ftoa__f64_to_str(f64 f, int n_digit) {
	strconv__ftoa__Uf64 u1 = (strconv__ftoa__Uf64){
		.f = 0,
		.u = 0,
	};
	u1.f = f;
	u64 u = u1.u;
	bool neg = (u >> (_const_strconv__ftoa__mantbits64 + _const_strconv__ftoa__expbits64)) != 0;
	u64 mant = (u & ((((u64)(1)) << _const_strconv__ftoa__mantbits64) - ((u64)(1))));
	u64 exp = ((u >> _const_strconv__ftoa__mantbits64) & ((((u64)(1)) << _const_strconv__ftoa__expbits64) - ((u64)(1))));
	if ((exp == _const_strconv__ftoa__maxexp64) || (exp == 0 && mant == 0)) {
		return strconv__ftoa__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__ftoa__Dec64_bool mr_9648 = strconv__ftoa__f64_to_decimal_exact_int(mant, exp);
	strconv__ftoa__Dec64 d = mr_9648.arg0;
	bool ok = mr_9648.arg1;
	if (!ok) {
		d = strconv__ftoa__f64_to_decimal(mant, exp);
	}
	return strconv__ftoa__Dec64_get_string_64(d, neg, n_digit);
}

inline
string strconv__ftoa__ftoa_64(f64 f) {
	return strconv__ftoa__f64_to_str(f, 17);
}

inline
string strconv__ftoa__ftoa_long_64(f64 f) {
	return strconv__ftoa__f64_to_str_l(f);
}

inline
string strconv__ftoa__ftoa_32(f32 f) {
	return strconv__ftoa__f32_to_str(f, 8);
}

inline
string strconv__ftoa__ftoa_long_32(f32 f) {
	return strconv__ftoa__f32_to_str_l(f);
}

void strconv__ftoa__assert1(bool t, string msg) {
	if (!t) {
		v_panic(msg);
	}
}

inline
int strconv__ftoa__bool_to_int(bool b) {
	if (b) {
		return 1;
	}
	return 0;
}

inline
u32 strconv__ftoa__bool_to_u32(bool b) {
	if (b) {
		return ((u32)(1));
	}
	return ((u32)(0));
}

inline
u64 strconv__ftoa__bool_to_u64(bool b) {
	if (b) {
		return ((u64)(1));
	}
	return ((u64)(0));
}

string strconv__ftoa__get_string_special(bool neg, bool expZero, bool mantZero) {
	if (!mantZero) {
		return tos3("nan");
	}
	if (!expZero) {
		if (neg) {
			return tos3("-inf");
		} else {
			return tos3("+inf");
		}
	}
	if (neg) {
		return tos3("-0e+00");
	}
	return tos3("0e+00");
}

int strconv__ftoa__decimal_len_32(u32 u) {
	strconv__ftoa__assert1(u < 1000000000, tos3("too big"));
	if (u >= 100000000) {
		return 9;
	} else if (u >= 10000000) {
		return 8;
	} else if (u >= 1000000) {
		return 7;
	} else if (u >= 100000) {
		return 6;
	} else if (u >= 10000) {
		return 5;
	} else if (u >= 1000) {
		return 4;
	} else if (u >= 100) {
		return 3;
	} else if (u >= 10) {
		return 2;
	}
	return 1;
}

u32 strconv__ftoa__mul_shift_32(u32 m, u64 mul, int ishift) {
	multi_return_u64_u64 mr_2333 = math__bits__mul_64(((u64)(m)), mul);
	u64 hi = mr_2333.arg0;
	u64 lo = mr_2333.arg1;
	u64 shifted_sum = (lo >> ((u64)(ishift))) + (hi << ((u64)(64 - ishift)));
	strconv__ftoa__assert1(shifted_sum <= 2147483647, tos3("shiftedSum <= math.max_u32"));
	return ((u32)(shifted_sum));
}

u32 strconv__ftoa__mul_pow5_invdiv_pow2(u32 m, u32 q, int j) {
	return strconv__ftoa__mul_shift_32(m, (*(u64*)array_get(_const_strconv__ftoa__pow5_inv_split_32, q)), j);
}

u32 strconv__ftoa__mul_pow5_div_pow2(u32 m, u32 i, int j) {
	return strconv__ftoa__mul_shift_32(m, (*(u64*)array_get(_const_strconv__ftoa__pow5_split_32, i)), j);
}

u32 strconv__ftoa__pow5_factor_32(u32 i_v) {
	u32 v = i_v;
	for (u32 n = ((u32)(0));
	; n++) {
		u32 q = v / 5;
		u32 r = v % 5;
		if (r != 0) {
			return n;
		}
		v = q;
	}
	return v;
}

bool strconv__ftoa__multiple_of_power_of_five_32(u32 v, u32 p) {
	return strconv__ftoa__pow5_factor_32(v) >= p;
}

bool strconv__ftoa__multiple_of_power_of_two_32(u32 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_32(v))) >= p;
}

u32 strconv__ftoa__log10_pow2(int e) {
	strconv__ftoa__assert1(e >= 0, tos3("e >= 0"));
	strconv__ftoa__assert1(e <= 1650, tos3("e <= 1650"));
	return (((u32)(e)) * 78913) >> 18;
}

u32 strconv__ftoa__log10_pow5(int e) {
	strconv__ftoa__assert1(e >= 0, tos3("e >= 0"));
	strconv__ftoa__assert1(e <= 2620, tos3("e <= 2620"));
	return (((u32)(e)) * 732923) >> 20;
}

int strconv__ftoa__pow5_bits(int e) {
	strconv__ftoa__assert1(e >= 0, tos3("e >= 0"));
	strconv__ftoa__assert1(e <= 3528, tos3("e <= 3528"));
	return ((int)(((((u32)(e)) * 1217359) >> 19) + 1));
}

int strconv__ftoa__decimal_len_64(u64 u) {
	int log2 = 64 - math__bits__leading_zeros_64(u) - 1;
	int t = (log2 + 1) * 1233 >> 12;
	return t - strconv__ftoa__bool_to_int(u < (*(u64*)array_get(_const_strconv__ftoa__powers_of_10, t))) + 1;
}

u64 strconv__ftoa__shift_right_128(strconv__ftoa__Uint128 v, int shift) {
	strconv__ftoa__assert1(shift < 64, tos3("shift < 64"));
	return ((v.hi << ((u64)(64 - shift))) | (v.lo >> ((u32)(shift))));
}

u64 strconv__ftoa__mul_shift_64(u64 m, strconv__ftoa__Uint128 mul, int shift) {
	multi_return_u64_u64 mr_5023 = math__bits__mul_64(m, mul.hi);
	u64 hihi = mr_5023.arg0;
	u64 hilo = mr_5023.arg1;
	multi_return_u64_u64 mr_5061 = math__bits__mul_64(m, mul.lo);
	u64 lohi = mr_5061.arg0;
	strconv__ftoa__Uint128 sum = (strconv__ftoa__Uint128){
		.hi = hihi,
		.lo = lohi + hilo,
	};
	if (sum.lo < lohi) {
		sum.hi++;
	}
	return strconv__ftoa__shift_right_128(sum, shift - 64);
}

u32 strconv__ftoa__pow5_factor_64(u64 v_i) {
	u64 v = v_i;
	for (u32 n = ((u32)(0));
	; n++) {
		u64 q = v / 5;
		u64 r = v % 5;
		if (r != 0) {
			return n;
		}
		v = q;
	}
	return ((u32)(0));
}

bool strconv__ftoa__multiple_of_power_of_five_64(u64 v, u32 p) {
	return strconv__ftoa__pow5_factor_64(v) >= p;
}

bool strconv__ftoa__multiple_of_power_of_two_64(u64 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_64(v))) >= p;
}

string strconv__ftoa__f32_to_str_l(f64 f) {
	return strconv__ftoa__f64_to_str_l(((f32)(f)));
}

string strconv__ftoa__f64_to_str_l(f64 f) {
	string s = strconv__ftoa__f64_to_str(f, 18);
	if (s.len > 2 && (string_at(s, 0) == 'n' || string_at(s, 1) == 'i')) {
		return s;
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	array_fixed_byte_26 b= {0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	for (int tmp2 = 0; tmp2 < s.len; tmp2++) {
	byte c = s.str[tmp2];
		if (c == '-') {
			sgn = -1;
			i++;
		} else if (c == '+') {
			sgn = 1;
			i++;
		} else if (c >= '0' && c <= '9') {
			b[i1++] = c;
			i++;
		} else if (c == '.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = i - 1;
			}
			i++;
		} else if (c == 'e') {
			i++;
			break;
		} else {
			return tos3("Float conversion error!!");
		}
	}
	b[i1] = 0;
	if (string_at(s, i) == '-') {
		exp_sgn = -1;
		i++;
	} else if (string_at(s, i) == '+') {
		exp_sgn = 1;
		i++;
	}
	for (int tmp6 = 0; tmp6 < string_substr(s, i, s.len).len; tmp6++) {
	byte c = string_substr(s, i, s.len).str[tmp6];
		exp = exp * 10 + ((int)(c - '0'));
	}
	array_byte res = array_repeat(new_array_from_c_array(1, 1, sizeof(byte), (byte[1]){
		'0', 
}), exp + 32);
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			array_set(&res, r_i++, &(byte[]) { '+' });
		}
	} else {
		array_set(&res, r_i++, &(byte[]) { '-' });
	}
	i = 0;
	if (exp_sgn >= 0) {
		while (b[i] != 0) {
			array_set(&res, r_i++, &(byte[]) { b[i] });
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					array_set(&res, r_i++, &(byte[]) { '.' });
				}
				exp--;
			}
		}
		while (exp >= 0) {
			array_set(&res, r_i++, &(byte[]) { '0' });
			exp--;
		}
	} else {
		bool dot_p = true;
		while (exp > 0) {
			array_set(&res, r_i++, &(byte[]) { '0' });
			exp--;
			if (dot_p) {
				array_set(&res, r_i++, &(byte[]) { '.' });
				dot_p = false;
			}
		}
		while (b[i] != 0) {
			array_set(&res, r_i++, &(byte[]) { b[i] });
			i++;
		}
	}
	array_set(&res, r_i, &(byte[]) { 0 });
	return tos(&(*(byte*)array_get(res, 0)), r_i);
}

u64 hash__wyhash__rand_u64(u64* seed) {
	return 0;
}


inline
u64 hash__wyhash__wyhash_c(byteptr key, u64 len, u64 seed) {
	return wyhash(key, len, seed);
}

inline
u64 hash__wyhash__sum64_string(string key, u64 seed) {
	return hash__wyhash__wyhash64(key.str, ((u64)(key.len)), seed);
}

inline
u64 hash__wyhash__sum64(array_byte key, u64 seed) {
	return hash__wyhash__wyhash64(key.data, ((u64)(key.len)), seed);
}

inline
u64 hash__wyhash__wyhash64(byteptr key, u64 len, u64 seed_) {
	if (len == 0) {
		return 0;
	}
	byte* p = &key[0];
	u64 seed = seed_;
	u64 i = (len & 63);
	if (i < 4) {
		seed = hash__wyhash__wymum(((hash__wyhash__wyr3(p, i) ^ seed) ^ _const_hash__wyhash__wyp0), (seed ^ _const_hash__wyhash__wyp1));
	} else if (i <= 8) {
		seed = hash__wyhash__wymum(((hash__wyhash__wyr4(p) ^ seed) ^ _const_hash__wyhash__wyp0), ((hash__wyhash__wyr4(p + i - 4) ^ seed) ^ _const_hash__wyhash__wyp1));
	} else if (i <= 16) {
		seed = hash__wyhash__wymum(((hash__wyhash__wyr8(p) ^ seed) ^ _const_hash__wyhash__wyp0), ((hash__wyhash__wyr8(p + i - 8) ^ seed) ^ _const_hash__wyhash__wyp1));
	} else if (i <= 24) {
		seed = (hash__wyhash__wymum(((hash__wyhash__wyr8(p) ^ seed) ^ _const_hash__wyhash__wyp0), ((hash__wyhash__wyr8(p + 8) ^ seed) ^ _const_hash__wyhash__wyp1)) ^ hash__wyhash__wymum(((hash__wyhash__wyr8(p + i - 8) ^ seed) ^ _const_hash__wyhash__wyp2), (seed ^ _const_hash__wyhash__wyp3)));
	} else if (i <= 32) {
		seed = (hash__wyhash__wymum(((hash__wyhash__wyr8(p) ^ seed) ^ _const_hash__wyhash__wyp0), ((hash__wyhash__wyr8(p + 8) ^ seed) ^ _const_hash__wyhash__wyp1)) ^ hash__wyhash__wymum(((hash__wyhash__wyr8(p + 16) ^ seed) ^ _const_hash__wyhash__wyp2), ((hash__wyhash__wyr8(p + i - 8) ^ seed) ^ _const_hash__wyhash__wyp3)));
	} else {
		seed = (((hash__wyhash__wymum(((hash__wyhash__wyr8(p) ^ seed) ^ _const_hash__wyhash__wyp0), ((hash__wyhash__wyr8(p + 8) ^ seed) ^ _const_hash__wyhash__wyp1)) ^ hash__wyhash__wymum(((hash__wyhash__wyr8(p + 16) ^ seed) ^ _const_hash__wyhash__wyp2), ((hash__wyhash__wyr8(p + 24) ^ seed) ^ _const_hash__wyhash__wyp3))) ^ hash__wyhash__wymum(((hash__wyhash__wyr8(p + i - 32) ^ seed) ^ _const_hash__wyhash__wyp1), ((hash__wyhash__wyr8(p + i - 24) ^ seed) ^ _const_hash__wyhash__wyp2))) ^ hash__wyhash__wymum(((hash__wyhash__wyr8(p + i - 16) ^ seed) ^ _const_hash__wyhash__wyp3), ((hash__wyhash__wyr8(p + i - 8) ^ seed) ^ _const_hash__wyhash__wyp0)));
	}
	if (i == len) {
		return hash__wyhash__wymum(seed, (len ^ _const_hash__wyhash__wyp4));
	}
	u64 see1 = seed;
	u64 see2 = seed;
	u64 see3 = seed;
	p = p + i;
	for (i = len - i;
	i >= 64; i -= 64) {
		seed = hash__wyhash__wymum(((hash__wyhash__wyr8(p) ^ seed) ^ _const_hash__wyhash__wyp0), ((hash__wyhash__wyr8(p + 8) ^ seed) ^ _const_hash__wyhash__wyp1));
		see1 = hash__wyhash__wymum(((hash__wyhash__wyr8(p + 16) ^ see1) ^ _const_hash__wyhash__wyp2), ((hash__wyhash__wyr8(p + 24) ^ see1) ^ _const_hash__wyhash__wyp3));
		see2 = hash__wyhash__wymum(((hash__wyhash__wyr8(p + 32) ^ see2) ^ _const_hash__wyhash__wyp1), ((hash__wyhash__wyr8(p + 40) ^ see2) ^ _const_hash__wyhash__wyp2));
		see3 = hash__wyhash__wymum(((hash__wyhash__wyr8(p + 48) ^ see3) ^ _const_hash__wyhash__wyp3), ((hash__wyhash__wyr8(p + 56) ^ see3) ^ _const_hash__wyhash__wyp0));
		p = p + 64;
	}
	return hash__wyhash__wymum(((seed ^ see1) ^ see2), ((see3 ^ len) ^ _const_hash__wyhash__wyp4));
}

inline
u64 hash__wyhash__wyrotr(u64 v, u32 k) {
	return ((v >> k) | (v << (64 - k)));
}

inline
u64 hash__wyhash__wymum(u64 a, u64 b) {
	u32 mask32 = ((u32)(4294967295));
	u64 x0 = (a & mask32);
	u64 x1 = a >> 32;
	u64 y0 = (b & mask32);
	u64 y1 = b >> 32;
	u64 w0 = x0 * y0;
	u64 t = x1 * y0 + (w0 >> 32);
	u64 w1 = (t & mask32);
	u64 w2 = t >> 32;
	w1 += x0 * y1;
	u64 hi = x1 * y1 + w2 + (w1 >> 32);
	u64 lo = a * b;
	return (hi ^ lo);
}

inline
u64 hash__wyhash__wyr3(byteptr p, u64 k) {
	return (((((u64)(p[0])) << 16) | (((u64)(p[k >> 1])) << 8)) | ((u64)(p[k - 1])));
}

inline
u64 hash__wyhash__wyr4(byteptr p) {
	return (((((u32)(p[0])) | (((u32)(p[1])) << ((u32)(8)))) | (((u32)(p[2])) << ((u32)(16)))) | (((u32)(p[3])) << ((u32)(24))));
}

inline
u64 hash__wyhash__wyr8(byteptr p) {
	return (((((((((u64)(p[0])) | (((u64)(p[1])) << 8)) | (((u64)(p[2])) << 16)) | (((u64)(p[3])) << 24)) | (((u64)(p[4])) << 32)) | (((u64)(p[5])) << 40)) | (((u64)(p[6])) << 48)) | (((u64)(p[7])) << 56));
}

multi_return_u32_u32_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0) {
	u32 r0 = ((u32)(0));
	u32 r1 = ((u32)(0));
	u32 r2 = ((u32)(0));
	r0 = ((s0 >> 1) | (((s1 & ((u32)(1)))) << 31));
	r1 = ((s1 >> 1) | (((s2 & ((u32)(1)))) << 31));
	r2 = s2 >> 1;
	return (multi_return_u32_u32_u32){.arg0=r2,.arg1=r1,.arg2=r0};
}

multi_return_u32_u32_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0) {
	u32 r0 = ((u32)(0));
	u32 r1 = ((u32)(0));
	u32 r2 = ((u32)(0));
	r2 = ((s2 << 1) | (((s1 & (((u32)(1)) << 31))) >> 31));
	r1 = ((s1 << 1) | (((s0 & (((u32)(1)) << 31))) >> 31));
	r0 = s0 << 1;
	return (multi_return_u32_u32_u32){.arg0=r2,.arg1=r1,.arg2=r0};
}

multi_return_u32_u32_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0) {
	u64 w = ((u64)(0));
	u32 r0 = ((u32)(0));
	u32 r1 = ((u32)(0));
	u32 r2 = ((u32)(0));
	w = ((u64)(s0)) + ((u64)(d0));
	r0 = ((u32)(w));
	w >>= 32;
	w += ((u64)(s1)) + ((u64)(d1));
	r1 = ((u32)(w));
	w >>= 32;
	w += ((u64)(s2)) + ((u64)(d2));
	r2 = ((u32)(w));
	return (multi_return_u32_u32_u32){.arg0=r2,.arg1=r1,.arg2=r0};
}

multi_return_u32_u32_u32 strconv__sub96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0) {
	u64 w = ((u64)(0));
	u32 r0 = ((u32)(0));
	u32 r1 = ((u32)(0));
	u32 r2 = ((u32)(0));
	w = ((u64)(s0)) - ((u64)(d0));
	r0 = ((u32)(w));
	w >>= 32;
	w += ((u64)(s1)) - ((u64)(d1));
	r1 = ((u32)(w));
	w >>= 32;
	w += ((u64)(s2)) - ((u64)(d2));
	r2 = ((u32)(w));
	return (multi_return_u32_u32_u32){.arg0=r2,.arg1=r1,.arg2=r0};
}

bool strconv__is_digit(byte x) {
	return (x >= _const_strconv__ZERO && x <= _const_strconv__NINE) == true;
}

bool strconv__is_space(byte x) {
	return ((x >= 0x89 && x <= 0x13) || x == 0x20) == true;
}

bool strconv__is_exp(byte x) {
	return (x == 'E' || x == 'e') == true;
}

multi_return_int_strconv__PrepNumber strconv__parser(string s) {
	int state = _const_strconv__fsm_a;
	int digx = 0;
	byte c = ' ';
	int result = _const_strconv__parser_ok;
	bool expneg = false;
	int expexp = 0;
	int i = 0;
	strconv__PrepNumber pn = (strconv__PrepNumber){
		.negative = 0,
		.exponent = 0,
		.mantissa = 0,
	};
	while (state != _const_strconv__FSM_STOP) {
		if (state == _const_strconv__fsm_a) {
			if (strconv__is_space(c) == true) {
				c = string_at(s, i++);
			} else {
				state = _const_strconv__fsm_b;
			}
		}
		else if (state == _const_strconv__fsm_b) {
			state = _const_strconv__fsm_c;
			if (c == _const_strconv__PLUS) {
				c = string_at(s, i++);
			} else if (c == _const_strconv__MINUS) {
				pn.negative = true;
				c = string_at(s, i++);
			} else if (strconv__is_digit(c)) {
			} else if (c == _const_strconv__DPOINT) {
			} else {
				state = _const_strconv__FSM_STOP;
			}
		}
		else if (state == _const_strconv__fsm_c) {
			if (c == _const_strconv__ZERO) {
				c = string_at(s, i++);
			} else if (c == _const_strconv__DPOINT) {
				c = string_at(s, i++);
				state = _const_strconv__fsm_d;
			} else {
				state = _const_strconv__fsm_e;
			}
		}
		else if (state == _const_strconv__fsm_d) {
			if (c == _const_strconv__ZERO) {
				c = string_at(s, i++);
				if (pn.exponent > -2147483647) {
					pn.exponent--;
				}
			} else {
				state = _const_strconv__fsm_f;
			}
		}
		else if (state == _const_strconv__fsm_e) {
			if (strconv__is_digit(c)) {
				if (digx < _const_strconv__DIGITS) {
					pn.mantissa *= 10;
					pn.mantissa += ((u64)(c - _const_strconv__ZERO));
					digx++;
				} else if (pn.exponent < 2147483647) {
					pn.exponent++;
				}
				c = string_at(s, i++);
			} else if (c == _const_strconv__DPOINT) {
				c = string_at(s, i++);
				state = _const_strconv__fsm_f;
			} else {
				state = _const_strconv__fsm_f;
			}
		}
		else if (state == _const_strconv__fsm_f) {
			if (strconv__is_digit(c)) {
				if (digx < _const_strconv__DIGITS) {
					pn.mantissa *= 10;
					pn.mantissa += ((u64)(c - _const_strconv__ZERO));
					pn.exponent--;
					digx++;
				}
				c = string_at(s, i++);
			} else if (strconv__is_exp(c)) {
				c = string_at(s, i++);
				state = _const_strconv__fsm_g;
			} else {
				state = _const_strconv__fsm_g;
			}
		}
		else if (state == _const_strconv__fsm_g) {
			if (c == _const_strconv__PLUS) {
				c = string_at(s, i++);
			} else if (c == _const_strconv__MINUS) {
				expneg = true;
				c = string_at(s, i++);
			}
			state = _const_strconv__fsm_h;
		}
		else if (state == _const_strconv__fsm_h) {
			if (c == _const_strconv__ZERO) {
				c = string_at(s, i++);
			} else {
				state = _const_strconv__fsm_i;
			}
		}
		else if (state == _const_strconv__fsm_i) {
			if (strconv__is_digit(c)) {
				if (expexp < 214748364) {
					expexp *= 10;
					expexp += ((int)(c - _const_strconv__ZERO));
				}
				c = string_at(s, i++);
			} else {
				state = _const_strconv__FSM_STOP;
			}
		}
		else {
		}
		;
		if (i >= s.len) {
			state = _const_strconv__FSM_STOP;
		}
	}
	if (expneg) {
		expexp = -expexp;
	}
	pn.exponent += expexp;
	if (pn.mantissa == 0) {
		if (pn.negative) {
			result = _const_strconv__parser_mzero;
		} else {
			result = _const_strconv__parser_pzero;
		}
	} else if (pn.exponent > 309) {
		if (pn.negative) {
			result = _const_strconv__parser_minf;
		} else {
			result = _const_strconv__parser_pinf;
		}
	} else if (pn.exponent < -328) {
		if (pn.negative) {
			result = _const_strconv__parser_mzero;
		} else {
			result = _const_strconv__parser_pzero;
		}
	}
	return (multi_return_int_strconv__PrepNumber){.arg0=result,.arg1=pn};
}

u64 strconv__converter(strconv__PrepNumber* pn) {
	int binexp = 92;
	u32 s2 = ((u32)(0));
	u32 s1 = ((u32)(0));
	u32 s0 = ((u32)(0));
	u32 q2 = ((u32)(0));
	u32 q1 = ((u32)(0));
	u32 q0 = ((u32)(0));
	u32 r2 = ((u32)(0));
	u32 r1 = ((u32)(0));
	u32 r0 = ((u32)(0));
	u32 mask28 = ((u32)(0xF << 28));
	u64 result = ((u64)(0));
	s0 = ((u32)((pn->mantissa & ((u64)(0x00000000FFFFFFFF)))));
	s1 = ((u32)(pn->mantissa >> 32));
	s2 = ((u32)(0));
	while (pn->exponent > 0) {
		multi_return_u32_u32_u32 mr_7893 = strconv__lsl96(s2, s1, s0);
		q2 = mr_7893.arg0;
		q1 = mr_7893.arg1;
		q0 = mr_7893.arg2;
		multi_return_u32_u32_u32 mr_7937 = strconv__lsl96(q2, q1, q0);
		r2 = mr_7937.arg0;
		r1 = mr_7937.arg1;
		r0 = mr_7937.arg2;
		multi_return_u32_u32_u32 mr_7991 = strconv__lsl96(r2, r1, r0);
		s2 = mr_7991.arg0;
		s1 = mr_7991.arg1;
		s0 = mr_7991.arg2;
		multi_return_u32_u32_u32 mr_8045 = strconv__add96(s2, s1, s0, q2, q1, q0);
		s2 = mr_8045.arg0;
		s1 = mr_8045.arg1;
		s0 = mr_8045.arg2;
		pn->exponent--;
		while (((s2 & mask28)) != 0) {
			multi_return_u32_u32_u32 mr_8166 = strconv__lsr96(s2, s1, s0);
			q2 = mr_8166.arg0;
			q1 = mr_8166.arg1;
			q0 = mr_8166.arg2;
			binexp++;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	while (pn->exponent < 0) {
		while (!(((s2 & (((u32)(1)) << 31))) != 0)) {
			multi_return_u32_u32_u32 mr_8309 = strconv__lsl96(s2, s1, s0);
			q2 = mr_8309.arg0;
			q1 = mr_8309.arg1;
			q0 = mr_8309.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
		q2 = s2 / _const_strconv__TEN;
		r1 = s2 % _const_strconv__TEN;
		r2 = ((s1 >> 8) | (r1 << 24));
		q1 = r2 / _const_strconv__TEN;
		r1 = r2 % _const_strconv__TEN;
		r2 = (((((s1 & ((u32)(0xFF)))) << 16) | (s0 >> 16)) | (r1 << 24));
		r0 = r2 / _const_strconv__TEN;
		r1 = r2 % _const_strconv__TEN;
		q1 = ((q1 << 8) | (((r0 & ((u32)(0x00FF0000)))) >> 16));
		q0 = r0 << 16;
		r2 = (((s0 & ((u32)(0xFFFF)))) | (r1 << 16));
		q0 |= r2 / _const_strconv__TEN;
		s2 = q2;
		s1 = q1;
		s0 = q0;
		pn->exponent++;
	}
	if (s2 != 0 || s1 != 0 || s0 != 0) {
		while (((s2 & mask28)) == 0) {
			multi_return_u32_u32_u32 mr_8954 = strconv__lsl96(s2, s1, s0);
			q2 = mr_8954.arg0;
			q1 = mr_8954.arg1;
			q0 = mr_8954.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	int nbit = 7;
	u32 check_round_bit = ((u32)(1)) << ((u32)(nbit));
	u32 check_round_mask = ((u32)(0xFFFFFFFF)) << ((u32)(nbit));
	if (((s1 & check_round_bit)) != 0) {
		if (((s1 & ~check_round_mask)) != 0) {
			multi_return_u32_u32_u32 mr_10027 = strconv__add96(s2, s1, s0, 0, check_round_bit, 0);
			s2 = mr_10027.arg0;
			s1 = mr_10027.arg1;
			s0 = mr_10027.arg2;
		} else {
			if (((s1 & (check_round_bit << ((u32)(1))))) != 0) {
				multi_return_u32_u32_u32 mr_10217 = strconv__add96(s2, s1, s0, 0, check_round_bit, 0);
				s2 = mr_10217.arg0;
				s1 = mr_10217.arg1;
				s0 = mr_10217.arg2;
			}
		}
		s1 = (s1 & check_round_mask);
		s0 = ((u32)(0));
		if ((s2 & (mask28 << ((u32)(1)))) != 0) {
			multi_return_u32_u32_u32 mr_10417 = strconv__lsr96(s2, s1, s0);
			q2 = mr_10417.arg0;
			q1 = mr_10417.arg1;
			q0 = mr_10417.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	binexp += 1023;
	if (binexp > 2046) {
		if (pn->negative) {
			result = _const_strconv__DOUBLE_MINUS_INFINITY;
		} else {
			result = _const_strconv__DOUBLE_PLUS_INFINITY;
		}
	} else if (binexp < 1) {
		if (pn->negative) {
			result = _const_strconv__DOUBLE_MINUS_ZERO;
		} else {
			result = _const_strconv__DOUBLE_PLUS_ZERO;
		}
	} else if (s2 != 0) {
		u64 q = ((u64)(0));
		u64 binexs2 = ((u64)(binexp)) << 52;
		q = (((((u64)((s2 & ~mask28))) << 24) | ((((u64)(s1)) + ((u64)(128))) >> 8)) | binexs2);
		if (pn->negative) {
			q |= (((u64)(1)) << 63);
		}
		result = q;
	}
	return result;
}

f64 strconv__atof64(string s) {
	strconv__PrepNumber pn = (strconv__PrepNumber){
		.negative = 0,
		.exponent = 0,
		.mantissa = 0,
	};
	int res_parsing = 0;
	strconv__Float64u res = (strconv__Float64u){
		.f = 0,
		.u = 0,
	};
	multi_return_int_strconv__PrepNumber mr_11564 = strconv__parser(string_add(s, tos3(" ")));
	res_parsing = mr_11564.arg0;
	pn = mr_11564.arg1;
	if (res_parsing == _const_strconv__parser_ok) {
		res.u = strconv__converter(&/*qq*/pn);
	}
	else if (res_parsing == _const_strconv__parser_pzero) {
		res.u = _const_strconv__DOUBLE_PLUS_ZERO;
	}
	else if (res_parsing == _const_strconv__parser_mzero) {
		res.u = _const_strconv__DOUBLE_MINUS_ZERO;
	}
	else if (res_parsing == _const_strconv__parser_pinf) {
		res.u = _const_strconv__DOUBLE_PLUS_INFINITY;
	}
	else if (res_parsing == _const_strconv__parser_minf) {
		res.u = _const_strconv__DOUBLE_MINUS_INFINITY;
	}
	else {
	}
	;
	return res.f;
}

byte strconv__byte_to_lower(byte c) {
	return (c | ('x' - 'X'));
}

u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	int bit_size = _bit_size;
	int base = _base;
	if (s.len < 1 || !strconv__underscore_ok(s)) {
		return ((u64)(0));
	}
	bool base0 = base == 0;
	int start_index = 0;
	if (2 <= base && base <= 36) {
	} else if (base == 0) {
		base = 10;
		if (string_at(s, 0) == '0') {
			if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'b') {
				base = 2;
				start_index += 2;
			} else if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'o') {
				base = 8;
				start_index += 2;
			} else if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'x') {
				base = 16;
				start_index += 2;
			} else if (s.len >= 2 && (string_at(s, 1) >= '0' && string_at(s, 1) <= '9')) {
				base = 10;
				start_index++;
			} else {
				base = 8;
				start_index++;
			}
		}
	} else {
		return ((u64)(0));
	}
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	} else if (bit_size < 0 || bit_size > 64) {
		return ((u64)(0));
	}
	u64 cutoff = _const_strconv__max_u64 / ((u64)(base)) + ((u64)(1));
	u64 max_val = (bit_size == 64 ? _const_strconv__max_u64 : (((u64)(1)) << ((u64)(bit_size))) - ((u64)(1)));
	bool underscores = false;
	u64 n = ((u64)(0));
	for (int tmp7 = start_index; tmp7 < s.len; tmp7++) {
		int i = tmp7;
		byte c = string_at(s, i);
		byte cl = strconv__byte_to_lower(c);
		byte d = ((byte)(0));
		if (c == '_' && base0) {
			underscores = true;
			continue;
		} else if ('0' <= c && c <= '9') {
			d = c - '0';
		} else if ('a' <= cl && cl <= 'z') {
			d = cl - 'a' + 10;
		} else {
			if (error_on_non_digit) {
				return ((u64)(0));
			} else {
				break;
			}
		}
		if (d >= ((byte)(base))) {
			if (error_on_high_digit) {
				return ((u64)(0));
			} else {
				break;
			}
		}
		if (n >= cutoff) {
			return max_val;
		}
		n *= ((u64)(base));
		u64 n1 = n + ((u64)(d));
		if (n1 < n || n1 > max_val) {
			return max_val;
		}
		n = n1;
	}
	if (underscores && !strconv__underscore_ok(s)) {
		return ((u64)(0));
	}
	return n;
}

u64 strconv__parse_uint(string s, int _base, int _bit_size) {
	return strconv__common_parse_uint(s, _base, _bit_size, true, true);
}

i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	string s = _s;
	int bit_size = _bit_size;
	if (s.len < 1) {
		return ((i64)(0));
	}
	bool neg = false;
	if (string_at(s, 0) == '+') {
		s = string_substr(s, 1, s.len);
	} else if (string_at(s, 0) == '-') {
		neg = true;
		s = string_substr(s, 1, s.len);
	}
	u64 un = strconv__common_parse_uint(s, base, bit_size, error_on_non_digit, error_on_high_digit);
	if (un == 0) {
		return ((i64)(0));
	}
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	}
	u64 cutoff = ((u64)(1)) << ((u64)(bit_size - 1));
	if (!neg && un >= cutoff) {
		return ((i64)(cutoff - ((u64)(1))));
	}
	if (neg && un > cutoff) {
		return -((i64)(cutoff));
	}
	return (neg ? -((i64)(un)) : ((i64)(un)));
}

i64 strconv__parse_int(string _s, int base, int _bit_size) {
	return strconv__common_parse_int(_s, base, _bit_size, true, true);
}

int strconv__atoi(string s) {
	if ((_const_strconv__int_size == 32 && (0 < s.len && s.len < 10)) || (_const_strconv__int_size == 64 && (0 < s.len && s.len < 19))) {
		int start_idx = 0;
		if (string_at(s, 0) == '-' || string_at(s, 0) == '+') {
			start_idx++;
			if (s.len - start_idx < 1) {
				return 0;
			}
		}
		int n = 0;
		for (int tmp4 = start_idx; tmp4 < s.len; tmp4++) {
			int i = tmp4;
			byte ch = string_at(s, i) - '0';
			if (ch > 9) {
				return 0;
			}
			n = n * 10 + ((int)(ch));
		}
		return (string_at(s, 0) == '-' ? -n : n);
	}
	i64 int64 = strconv__parse_int(s, 10, 0);
	return ((int)(int64));
}

bool strconv__underscore_ok(string s) {
	byte saw = '^';
	int i = 0;
	if (s.len >= 1 && (string_at(s, 0) == '-' || string_at(s, 0) == '+')) {
		i++;
	}
	bool hex = false;
	if (s.len - i >= 2 && string_at(s, i) == '0' && (strconv__byte_to_lower(string_at(s, i + 1)) == 'b' || strconv__byte_to_lower(string_at(s, i + 1)) == 'o' || strconv__byte_to_lower(string_at(s, i + 1)) == 'x')) {
		saw = '0';
		hex = strconv__byte_to_lower(string_at(s, i + 1)) == 'x';
		i += 2;
	}
	for (; i < s.len; i++) {
		if (('0' <= string_at(s, i) && string_at(s, i) <= '9') || (hex && 'a' <= strconv__byte_to_lower(string_at(s, i)) && strconv__byte_to_lower(string_at(s, i)) <= 'f')) {
			saw = '0';
			continue;
		}
		if (string_at(s, i) == '_') {
			if (saw != '0') {
				return false;
			}
			saw = '_';
			continue;
		}
		if (saw == '_') {
			return false;
		}
		saw = '!';
	}
	return saw != '_';
}

rand__Pcg32 rand__new_pcg32(u64 initstate, u64 initseq) {
	rand__Pcg32 rng = (rand__Pcg32){
		.state = 0,
		.inc = 0,
	};
	rng.state = ((u64)(0));
	rng.inc = ((initseq << ((u64)(1))) | ((u64)(1)));
	rand__Pcg32_next(&rng);
	rng.state += initstate;
	rand__Pcg32_next(&rng);
	return rng;
}

inline
u32 rand__Pcg32_next(rand__Pcg32* rng) {
	u64 oldstate = rng->state;
	rng->state = oldstate * (6364136223846793005) + rng->inc;
	u32 xorshifted = ((u32)((((oldstate >> ((u64)(18))) ^ oldstate)) >> ((u64)(27))));
	u32 rot = ((u32)(oldstate >> ((u64)(59))));
	return (((xorshifted >> rot) | (xorshifted << (((-rot) & ((u32)(31)))))));
}

inline
u32 rand__Pcg32_bounded_next(rand__Pcg32* rng, u32 bound) {
	u32 threshold = (-bound % bound);
	while (1) {
		u32 r = rand__Pcg32_next(rng);
		if (r >= threshold) {
			return (r % bound);
		}
	}
	return ((u32)(0));
}



void rand__seed(int s) {
	srand(s);
}

int rand__next(int max) {
	return rand() % max;
}

int rand__rand_r(int* seed) {
	int ns = *seed * 1103515245 + 12345;
	(*seed) = ns;
	return (ns & 0x7fffffff);
}

rand__Splitmix64 rand__new_splitmix64(u64 seed) {
	return (rand__Splitmix64){
		.state = seed,
	};
}

inline
u64 rand__Splitmix64_next(rand__Splitmix64* rng) {
	rng->state += (0x9e3779b97f4a7c15);
	u64 z = rng->state;
	z = ((z ^ ((z >> ((u64)(30)))))) * (0xbf58476d1ce4e5b9);
	z = ((z ^ ((z >> ((u64)(27)))))) * (0x94d049bb133111eb);
	return (z ^ (z >> (31)));
}

inline
u64 rand__Splitmix64_bounded_next(rand__Splitmix64* rng, u64 bound) {
	u64 threshold = -bound % bound;
	while (1) {
		u64 r = rand__Splitmix64_next(rng);
		if (r >= threshold) {
			return r % bound;
		}
	}
	return ((u64)(0));
}

string time__Time_format(time__Time t) {
	return time__Time_get_fmt_str(t, time__FormatDelimiter_hyphen, time__FormatTime_hhmm24, time__FormatDate_yyyymmdd);
}

string time__Time_format_ss(time__Time t) {
	return time__Time_get_fmt_str(t, time__FormatDelimiter_hyphen, time__FormatTime_hhmmss24, time__FormatDate_yyyymmdd);
}

string time__Time_hhmm(time__Time t) {
	return time__Time_get_fmt_time_str(t, time__FormatTime_hhmm24);
}

string time__Time_hhmmss(time__Time t) {
	return time__Time_get_fmt_time_str(t, time__FormatTime_hhmmss24);
}

string time__Time_hhmm12(time__Time t) {
	return time__Time_get_fmt_time_str(t, time__FormatTime_hhmm12);
}

string time__Time_ymmdd(time__Time t) {
	return time__Time_get_fmt_date_str(t, time__FormatDelimiter_hyphen, time__FormatDate_yyyymmdd);
}

string time__Time_ddmmy(time__Time t) {
	return time__Time_get_fmt_date_str(t, time__FormatDelimiter_dot, time__FormatDate_ddmmyyyy);
}

string time__Time_md(time__Time t) {
	return time__Time_get_fmt_date_str(t, time__FormatDelimiter_space, time__FormatDate_mmmd);
}

string time__Time_clean(time__Time t) {
	time__Time now = time__now();
	if (t.month == now.month && t.year == now.year && t.day == now.day) {
		return time__Time_get_fmt_time_str(t, time__FormatTime_hhmm24);
	}
	if (t.year == now.year) {
		return time__Time_get_fmt_str(t, time__FormatDelimiter_space, time__FormatTime_hhmm24, time__FormatDate_mmmd);
	}
	return time__Time_format(t);
}

string time__Time_clean12(time__Time t) {
	time__Time now = time__now();
	if (t.month == now.month && t.year == now.year && t.day == now.day) {
		return time__Time_get_fmt_time_str(t, time__FormatTime_hhmm12);
	}
	if (t.year == now.year) {
		return time__Time_get_fmt_str(t, time__FormatDelimiter_space, time__FormatTime_hhmm12, time__FormatDate_mmmd);
	}
	return time__Time_format(t);
}

string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time) {
	if (fmt_time == time__FormatTime_no_time) {
		return tos3("");
	}
	string tp = (t.hour > 11 ? tos3("p.m.") : tos3("a.m."));
	int hour = (t.hour > 12 ? t.hour - 12 : t.hour == 0 ? 12 : t.hour);
	return (fmt_time == time__FormatTime_hhmm12) ? _STR("%d:%02d %.*s", hour, t.minute, tp.len, tp.str) : (fmt_time == time__FormatTime_hhmm24) ? _STR("%02d:%02d", t.hour, t.minute) : (fmt_time == time__FormatTime_hhmmss12) ? _STR("%d:%02d:%02d %.*s", hour, t.minute, t.second, tp.len, tp.str) : (fmt_time == time__FormatTime_hhmmss24) ? _STR("%02d:%02d:%02d", t.hour, t.minute, t.second) : _STR("unknown enumeration %.*s", time__FormatTime_str(fmt_time).len, time__FormatTime_str(fmt_time).str);
}

string time__Time_get_fmt_date_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatDate fmt_date) {
	if (fmt_date == time__FormatDate_no_date) {
		return tos3("");
	}
	string month = _STR("%.*s", time__Time_smonth(t).len, time__Time_smonth(t).str);
	string year = string_substr(int_str(t.year), 2, int_str(t.year).len);
	string res = (fmt_date == time__FormatDate_ddmmyy) ? _STR("%02d|%02d|%.*s", t.day, t.month, year.len, year.str) : (fmt_date == time__FormatDate_ddmmyyyy) ? _STR("%02d|%02d|%d", t.day, t.month, t.year) : (fmt_date == time__FormatDate_mmddyy) ? _STR("%02d|%02d|%.*s", t.month, t.day, year.len, year.str) : (fmt_date == time__FormatDate_mmddyyyy) ? _STR("%02d|%02d|%d", t.month, t.day, t.year) : (fmt_date == time__FormatDate_mmmd) ? _STR("%.*s|%d", month.len, month.str, t.day) : (fmt_date == time__FormatDate_mmmdd) ? _STR("%.*s|%02d", month.len, month.str, t.day) : (fmt_date == time__FormatDate_mmmddyyyy) ? _STR("%.*s|%02d|%d", month.len, month.str, t.day, t.year) : (fmt_date == time__FormatDate_yyyymmdd) ? _STR("%d|%02d|%02d", t.year, t.month, t.day) : _STR("unknown enumeration %.*s", time__FormatDate_str(fmt_date).len, time__FormatDate_str(fmt_date).str);
	res = string_replace(res, tos3("|"), (fmt_dlmtr == time__FormatDelimiter_dot) ? tos3(".") : (fmt_dlmtr == time__FormatDelimiter_hyphen) ? tos3("-") : (fmt_dlmtr == time__FormatDelimiter_slash) ? tos3("/") : (fmt_dlmtr == time__FormatDelimiter_space) ? tos3(" ") : _STR("unknown enumeration %.*s", time__FormatDelimiter_str(fmt_dlmtr).len, time__FormatDelimiter_str(fmt_dlmtr).str));
	return res;
}

string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatTime fmt_time, time__FormatDate fmt_date) {
	if (fmt_date == time__FormatDate_no_date) {
		if (fmt_time == time__FormatTime_no_time) {
			return tos3("");
		} else {
			return time__Time_get_fmt_time_str(t, fmt_time);
		}
	} else {
		if (fmt_time != time__FormatTime_no_time) {
			return string_add(string_add(time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date), tos3(" ")), time__Time_get_fmt_time_str(t, fmt_time));
		} else {
			return time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date);
		}
	}
}

Option_time__Time time__parse(string s) {
	Option_int pos = string_index(s, tos3(" "));
	if (!pos.ok) {
		string err = pos.v_error;
		int errcode = pos.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return v_error(_STR("Invalid time format: %.*s", s.len, s.str));
	};
	string symd = string_substr(s, 0, /*opt*/(*(int*)pos.data));
	array_string ymd = string_split(symd, tos3("-"));
	if (ymd.len != 3) {
		return v_error(_STR("Invalid time format: %.*s", s.len, s.str));
	}
	string shms = string_substr(s, /*opt*/(*(int*)pos.data), s.len);
	array_string hms = string_split(shms, tos3(":"));
	string hour = string_substr((*(string*)array_get(hms, 0)), 1, (*(string*)array_get(hms, 0)).len);
	string minute = (*(string*)array_get(hms, 1));
	string second = (*(string*)array_get(hms, 2));
	time__Time res = time__new_time((time__Time){
		.year = string_int((*(string*)array_get(ymd, 0))),
		.month = string_int((*(string*)array_get(ymd, 1))),
		.day = string_int((*(string*)array_get(ymd, 2))),
		.hour = string_int(hour),
		.minute = string_int(minute),
		.second = string_int(second),
		.v_unix = 0,
	});
	return /*:)time.Time*/opt_ok(&(time__Time []) { res }, sizeof(time__Time));
}

Option_time__Time time__parse_rfc2822(string s) {
	array_string fields = string_split(s, tos3(" "));
	if (fields.len < 5) {
		return v_error(_STR("Invalid time format: %.*s", s.len, s.str));
	}
	Option_int pos = string_index(_const_time__months_string, (*(string*)array_get(fields, 2)));
	if (!pos.ok) {
		string err = pos.v_error;
		int errcode = pos.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return v_error(_STR("Invalid time format: %.*s", s.len, s.str));
	};
	int mm = /*opt*/(*(int*)pos.data) / 3 + 1;
	byteptr tmstr = ((byteptr)(0));
		tmstr = v_malloc(s.len * 2);
	int count = snprintf(((charptr)(tmstr)), (s.len * 2), "%s-%02d-%s %s", (*(string*)array_get(fields, 3)).str, mm, (*(string*)array_get(fields, 1)).str, (*(string*)array_get(fields, 4)).str);
	Option_time__Time t = time__parse(tos(tmstr, count));
	if (!t.ok) {
		string err = t.v_error;
		int errcode = t.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return v_error(_STR("Invalid time format: %.*s", s.len, s.str));
	};
	return /*:)time.Time*/opt_ok(&(time__Time []) { /*opt*/(*(time__Time*)t.data) }, sizeof(time__Time));
}

// TypeDecl


time__Time time__now() {
	time__time_t t = time(0);
	struct tm* now = ((struct tm*)(0));
	now = localtime(&t);
	return time__convert_ctime(*/*d*/now);
}

string time__Time_smonth(time__Time t) {
	int i = t.month - 1;
	return string_substr(_const_time__months_string, i * 3, (i + 1) * 3);
}

time__Time time__new_time(time__Time t) {
	return (time__Time){
		.year = t.year,
		.month = t.month,
		.day = t.day,
		.hour = t.hour,
		.minute = t.minute,
		.second = t.second,
		.v_unix = time__Time_unix_time(t),
	};
}

int time__Time_unix_time(time__Time t) {
	if (t.v_unix != 0) {
		return t.v_unix;
	}
	struct tm tt = (struct tm){
		.tm_sec = t.second,
		.tm_min = t.minute,
		.tm_hour = t.hour,
		.tm_mday = t.day,
		.tm_mon = t.month - 1,
		.tm_year = t.year - 1900,
	};
	return time__make_unix_time(tt);
}

time__Time time__Time_add_seconds(time__Time t, int seconds) {
	return time__unix(t.v_unix + seconds);
}

time__Time time__Time_add_days(time__Time t, int days) {
	return time__unix(t.v_unix + days * 3600 * 24);
}

int time__since(time__Time t) {
	return 0;
}

string time__Time_relative(time__Time t) {
	time__Time now = time__now();
	u64 secs = now.v_unix - t.v_unix;
	if (secs <= 30) {
		return tos3("now");
	}
	if (secs < 60) {
		return tos3("1m");
	}
	if (secs < 3600) {
		return _STR("%dm", secs / 60);
	}
	if (secs < 3600 * 24) {
		return _STR("%dh", secs / 3600);
	}
	if (secs < 3600 * 24 * 5) {
		return _STR("%dd", secs / 3600 / 24);
	}
	if (secs > 3600 * 24 * 10000) {
		return tos3("");
	}
	return time__Time_md(t);
}

int time__day_of_week(int y, int m, int d) {
	array_int t = new_array_from_c_array(12, 12, sizeof(int), (int[12]){
		0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4, 
});
	int sy = y;
	if (m < 3) {
		sy = sy - 1;
	}
	return (sy + sy / 4 - sy / 100 + sy / 400 + (*(int*)array_get(t, m - 1)) + d - 1) % 7 + 1;
}

int time__Time_day_of_week(time__Time t) {
	return time__day_of_week(t.year, t.month, t.day);
}

string time__Time_weekday_str(time__Time t) {
	int i = time__Time_day_of_week(t) - 1;
	return string_substr(_const_time__days_string, i * 3, (i + 1) * 3);
}

i64 time__ticks() {
	
#ifdef _WIN32
	// #if windows
		return GetTickCount();
	
#else
		struct timeval ts = (struct timeval){
			.tv_sec = 0,
			.tv_usec = 0,
		};
		gettimeofday(&ts, 0);
		return ((i64)(ts.tv_sec * ((u64)(1000)) + (ts.tv_usec / ((u64)(1000)))));
	
#endif
}

void time__sleep(int seconds) {
	
#ifdef _WIN32
	// #if windows
		Sleep(seconds * 1000);
	
#else
		sleep(seconds);
	
#endif
}

void time__sleep_ms(int milliseconds) {
	
#ifdef _WIN32
	// #if windows
		Sleep(milliseconds);
	
#else
		usleep(milliseconds * 1000);
	
#endif
}

void time__usleep(int microseconds) {
	
#ifdef _WIN32
	// #if windows
		int milliseconds = microseconds / 1000;
		Sleep(milliseconds);
	
#else
		usleep(microseconds);
	
#endif
}

bool time__is_leap_year(int year) {
	return (year % 4 == 0) && (year % 100 != 0 || year % 400 == 0);
}

Option_int time__days_in_month(int month, int year) {
	if (month > 12 || month < 1) {
		return v_error(_STR("Invalid month: %d", month));
	}
	int extra = (month == 2 && time__is_leap_year(year) ? 1 : 0);
	int res = (*(int*)array_get(_const_time__month_days, month - 1)) + extra;
	return /*:)int*/opt_ok(&(int []) { res }, sizeof(int));
}

string time__Time_str(time__Time t) {
	return time__Time_format_ss(t);
}

time__Time time__convert_ctime(struct tm t) {
	return (time__Time){
		.year = t.tm_year + 1900,
		.month = t.tm_mon + 1,
		.day = t.tm_mday,
		.hour = t.tm_hour,
		.minute = t.tm_min,
		.second = t.tm_sec,
		.v_unix = time__make_unix_time(t),
	};
}


int time__make_unix_time(struct tm t) {
	return ((int)(timegm(&t)));
}

time__Time time__unix(int abs) {
	int day_offset = abs / _const_time__seconds_per_day;
	if (abs % _const_time__seconds_per_day < 0) {
		day_offset--;
	}
	multi_return_int_int_int mr_473 = time__calculate_date_from_offset(day_offset);
	int year = mr_473.arg0;
	int month = mr_473.arg1;
	int day = mr_473.arg2;
	multi_return_int_int_int mr_527 = time__calculate_time_from_offset(abs % _const_time__seconds_per_day);
	int hr = mr_527.arg0;
	int min = mr_527.arg1;
	int sec = mr_527.arg2;
	return (time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hr,
		.minute = min,
		.second = sec,
		.v_unix = abs,
	};
}

inline
multi_return_int_int_int time__calculate_date_from_offset(int day_offset_) {
	int day_offset = day_offset_;
	int year = 2001;
	day_offset -= 31 * 365 + 8;
	year += (day_offset / _const_time__days_per_400_years) * 400;
	day_offset %= _const_time__days_per_400_years;
	if (day_offset == _const_time__days_per_100_years * 4) {
		year += 300;
		day_offset -= _const_time__days_per_100_years * 3;
	} else {
		year += (day_offset / _const_time__days_per_100_years) * 100;
		day_offset %= _const_time__days_per_100_years;
	}
	if (day_offset == _const_time__days_per_4_years * 25) {
		year += 96;
		day_offset -= _const_time__days_per_4_years * 24;
	} else {
		year += (day_offset / _const_time__days_per_4_years) * 4;
		day_offset %= _const_time__days_per_4_years;
	}
	if (day_offset == 365 * 4) {
		year += 3;
		day_offset -= 365 * 3;
	} else {
		year += (day_offset / 365);
		day_offset %= 365;
	}
	if (day_offset < 0) {
		year--;
		if (time__is_leap_year(year)) {
			day_offset += 366;
		} else {
			day_offset += 365;
		}
	}
	if (time__is_leap_year(year)) {
		if (day_offset > 31 + 29 - 1) {
			day_offset--;
		} else if (day_offset == 31 + 29 - 1) {
			return (multi_return_int_int_int){.arg0=year,.arg1=2,.arg2=29};
		}
	}
	int estimated_month = day_offset / 31;
	while (day_offset >= (*(int*)array_get(_const_time__days_before, estimated_month + 1))) {
		estimated_month++;
	}
	while (day_offset < (*(int*)array_get(_const_time__days_before, estimated_month))) {
		if (estimated_month == 0) {
			break;
		}
		estimated_month--;
	}
	day_offset -= (*(int*)array_get(_const_time__days_before, estimated_month));
	return (multi_return_int_int_int){.arg0=year,.arg1=estimated_month + 1,.arg2=day_offset + 1};
}

inline
multi_return_int_int_int time__calculate_time_from_offset(int second_offset_) {
	int second_offset = second_offset_;
	if (second_offset < 0) {
		second_offset += _const_time__seconds_per_day;
	}
	int hour = second_offset / _const_time__seconds_per_hour;
	second_offset %= _const_time__seconds_per_hour;
	int min = second_offset / _const_time__seconds_per_minute;
	second_offset %= _const_time__seconds_per_minute;
	return (multi_return_int_int_int){.arg0=hour,.arg1=min,.arg2=second_offset};
}

int math__bits__leading_zeros_8(byte x) {
	return 8 - math__bits__len_8(x);
}

int math__bits__leading_zeros_16(u16 x) {
	return 16 - math__bits__len_16(x);
}

int math__bits__leading_zeros_32(u32 x) {
	return 32 - math__bits__len_32(x);
}

int math__bits__leading_zeros_64(u64 x) {
	return 64 - math__bits__len_64(x);
}

int math__bits__trailing_zeros_8(byte x) {
	return ((int)((*(byte*)array_get(_const_math__bits__ntz_8_tab, x))));
}

int math__bits__trailing_zeros_16(u16 x) {
	if (x == 0) {
		return 16;
	}
	return ((int)((*(byte*)array_get(_const_math__bits__de_bruijn32tab, ((u32)((x & -x))) * _const_math__bits__de_bruijn32 >> (32 - 5)))));
}

int math__bits__trailing_zeros_32(u32 x) {
	if (x == 0) {
		return 32;
	}
	return ((int)((*(byte*)array_get(_const_math__bits__de_bruijn32tab, ((x & -x)) * _const_math__bits__de_bruijn32 >> (32 - 5)))));
}

int math__bits__trailing_zeros_64(u64 x) {
	if (x == 0) {
		return 64;
	}
	return ((int)((*(byte*)array_get(_const_math__bits__de_bruijn64tab, ((x & -x)) * _const_math__bits__de_bruijn64 >> (64 - 6)))));
}

int math__bits__ones_count_8(byte x) {
	return ((int)((*(byte*)array_get(_const_math__bits__pop_8_tab, x))));
}

int math__bits__ones_count_16(u16 x) {
	return ((int)((*(byte*)array_get(_const_math__bits__pop_8_tab, x >> 8)) + (*(byte*)array_get(_const_math__bits__pop_8_tab, (x & ((u16)(0xff)))))));
}

int math__bits__ones_count_32(u32 x) {
	return ((int)((*(byte*)array_get(_const_math__bits__pop_8_tab, x >> 24)) + (*(byte*)array_get(_const_math__bits__pop_8_tab, (x >> 16 & 0xff))) + (*(byte*)array_get(_const_math__bits__pop_8_tab, (x >> 8 & 0xff))) + (*(byte*)array_get(_const_math__bits__pop_8_tab, (x & ((u32)(0xff)))))));
}

int math__bits__ones_count_64(u64 x) {
	u64 y = ((x >> ((u64)(1)) & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) + ((x & ((_const_math__bits__m0 & _const_math__bits__max_u64))));
	y = ((y >> ((u64)(2)) & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) + ((y & ((_const_math__bits__m1 & _const_math__bits__max_u64))));
	y = (((y >> 4) + y) & ((_const_math__bits__m2 & _const_math__bits__max_u64)));
	y += y >> 8;
	y += y >> 16;
	y += y >> 32;
	return (((int)(y)) & ((1 << 7) - 1));
}

inline
byte math__bits__rotate_left_8(byte x, int k) {
	byte n = ((byte)(8));
	byte s = (((byte)(k)) & (n - ((byte)(1))));
	return (((x << s) | (x >> (n - s))));
}

inline
u16 math__bits__rotate_left_16(u16 x, int k) {
	u16 n = ((u16)(16));
	u16 s = (((u16)(k)) & (n - ((u16)(1))));
	return (((x << s) | (x >> (n - s))));
}

inline
u32 math__bits__rotate_left_32(u32 x, int k) {
	u32 n = ((u32)(32));
	u32 s = (((u32)(k)) & (n - ((u32)(1))));
	return (((x << s) | (x >> (n - s))));
}

inline
u64 math__bits__rotate_left_64(u64 x, int k) {
	u64 n = ((u64)(64));
	u64 s = (((u64)(k)) & (n - ((u64)(1))));
	return (((x << s) | (x >> (n - s))));
}

inline
byte math__bits__reverse_8(byte x) {
	return (*(byte*)array_get(_const_math__bits__rev_8_tab, x));
}

inline
u16 math__bits__reverse_16(u16 x) {
	return (((u16)((*(byte*)array_get(_const_math__bits__rev_8_tab, x >> 8)))) | (((u16)((*(byte*)array_get(_const_math__bits__rev_8_tab, (x & ((u16)(0xff))))))) << 8));
}

inline
u32 math__bits__reverse_32(u32 x) {
	u32 y = ((((x >> ((u32)(1)) & ((_const_math__bits__m0 & _const_math__bits__max_u32)))) | (((x & ((_const_math__bits__m0 & _const_math__bits__max_u32)))) << 1)));
	y = ((((y >> ((u32)(2)) & ((_const_math__bits__m1 & _const_math__bits__max_u32)))) | (((y & ((_const_math__bits__m1 & _const_math__bits__max_u32)))) << ((u32)(2)))));
	y = ((((y >> ((u32)(4)) & ((_const_math__bits__m2 & _const_math__bits__max_u32)))) | (((y & ((_const_math__bits__m2 & _const_math__bits__max_u32)))) << ((u32)(4)))));
	return math__bits__reverse_bytes_32(y);
}

inline
u64 math__bits__reverse_64(u64 x) {
	u64 y = ((((x >> ((u64)(1)) & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) | (((x & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) << 1)));
	y = ((((y >> ((u64)(2)) & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) << 2)));
	y = ((((y >> ((u64)(4)) & ((_const_math__bits__m2 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m2 & _const_math__bits__max_u64)))) << 4)));
	return math__bits__reverse_bytes_64(y);
}

inline
u16 math__bits__reverse_bytes_16(u16 x) {
	return ((x >> 8) | (x << 8));
}

inline
u32 math__bits__reverse_bytes_32(u32 x) {
	u32 y = ((((x >> ((u32)(8)) & ((_const_math__bits__m3 & _const_math__bits__max_u32)))) | (((x & ((_const_math__bits__m3 & _const_math__bits__max_u32)))) << ((u32)(8)))));
	return ((y >> 16) | (y << 16));
}

inline
u64 math__bits__reverse_bytes_64(u64 x) {
	u64 y = ((((x >> ((u64)(8)) & ((_const_math__bits__m3 & _const_math__bits__max_u64)))) | (((x & ((_const_math__bits__m3 & _const_math__bits__max_u64)))) << ((u64)(8)))));
	y = ((((y >> ((u64)(16)) & ((_const_math__bits__m4 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m4 & _const_math__bits__max_u64)))) << ((u64)(16)))));
	return ((y >> 32) | (y << 32));
}

int math__bits__len_8(byte x) {
	return ((int)((*(byte*)array_get(_const_math__bits__len_8_tab, x))));
}

int math__bits__len_16(u16 x) {
	u16 y = x;
	int n = 0;
	if (y >= 1 << 8) {
		y >>= 8;
		n = 8;
	}
	return n + ((int)((*(byte*)array_get(_const_math__bits__len_8_tab, y))));
}

int math__bits__len_32(u32 x) {
	u32 y = x;
	int n = 0;
	if (y >= (1 << 16)) {
		y >>= 16;
		n = 16;
	}
	if (y >= (1 << 8)) {
		y >>= 8;
		n += 8;
	}
	return n + ((int)((*(byte*)array_get(_const_math__bits__len_8_tab, y))));
}

int math__bits__len_64(u64 x) {
	u64 y = x;
	int n = 0;
	if (y >= ((u64)(1)) << ((u64)(32))) {
		y >>= 32;
		n = 32;
	}
	if (y >= ((u64)(1)) << ((u64)(16))) {
		y >>= 16;
		n += 16;
	}
	if (y >= ((u64)(1)) << ((u64)(8))) {
		y >>= 8;
		n += 8;
	}
	return n + ((int)((*(byte*)array_get(_const_math__bits__len_8_tab, y))));
}

multi_return_u32_u32 math__bits__add_32(u32 x, u32 y, u32 carry) {
	u64 sum64 = ((u64)(x)) + ((u64)(y)) + ((u64)(carry));
	u32 sum = ((u32)(sum64));
	u32 carry_out = ((u32)(sum64 >> 32));
	return (multi_return_u32_u32){.arg0=sum,.arg1=carry_out};
}

multi_return_u64_u64 math__bits__add_64(u64 x, u64 y, u64 carry) {
	u64 sum = x + y + carry;
	u64 carry_out = ((((x & y)) | ((((x | y)) & ~sum)))) >> 63;
	return (multi_return_u64_u64){.arg0=sum,.arg1=carry_out};
}

multi_return_u32_u32 math__bits__sub_32(u32 x, u32 y, u32 borrow) {
	u32 diff = x - y - borrow;
	u32 borrow_out = ((((~x & y)) | ((~((x ^ y)) & diff)))) >> 31;
	return (multi_return_u32_u32){.arg0=diff,.arg1=borrow_out};
}

multi_return_u64_u64 math__bits__sub_64(u64 x, u64 y, u64 borrow) {
	u64 diff = x - y - borrow;
	u64 borrow_out = ((((~x & y)) | ((~((x ^ y)) & diff)))) >> 63;
	return (multi_return_u64_u64){.arg0=diff,.arg1=borrow_out};
}

multi_return_u32_u32 math__bits__mul_32(u32 x, u32 y) {
	u64 tmp = ((u64)(x)) * ((u64)(y));
	u32 hi = ((u32)(tmp >> 32));
	u32 lo = ((u32)(tmp));
	return (multi_return_u32_u32){.arg0=hi,.arg1=lo};
}

multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y) {
	u64 x0 = (x & _const_math__bits__mask32);
	u64 x1 = x >> 32;
	u64 y0 = (y & _const_math__bits__mask32);
	u64 y1 = y >> 32;
	u64 w0 = x0 * y0;
	u64 t = x1 * y0 + (w0 >> 32);
	u64 w1 = (t & _const_math__bits__mask32);
	u64 w2 = t >> 32;
	w1 += x0 * y1;
	u64 hi = x1 * y1 + w2 + (w1 >> 32);
	u64 lo = x * y;
	return (multi_return_u64_u64){.arg0=hi,.arg1=lo};
}

multi_return_u32_u32 math__bits__div_32(u32 hi, u32 lo, u32 y) {
	if (y != 0 && y <= hi) {
		v_panic(_const_math__bits__overflow_error);
	}
	u64 z = ((((u64)(hi)) << 32) | ((u64)(lo)));
	u32 quo = ((u32)(z / ((u64)(y))));
	u32 rem = ((u32)(z % ((u64)(y))));
	return (multi_return_u32_u32){.arg0=quo,.arg1=rem};
}

multi_return_u64_u64 math__bits__div_64(u64 hi, u64 lo, u64 y1) {
	u64 y = y1;
	if (y == 0) {
		v_panic(_const_math__bits__overflow_error);
	}
	if (y <= hi) {
		v_panic(_const_math__bits__overflow_error);
	}
	u32 s = ((u32)(math__bits__leading_zeros_64(y)));
	y <<= s;
	u64 yn1 = y >> 32;
	u64 yn0 = (y & _const_math__bits__mask32);
	u64 un32 = ((hi << s) | (lo >> (64 - s)));
	u64 un10 = lo << s;
	u64 un1 = un10 >> 32;
	u64 un0 = (un10 & _const_math__bits__mask32);
	u64 q1 = un32 / yn1;
	u64 rhat = un32 - q1 * yn1;
	while (q1 >= _const_math__bits__two32 || q1 * yn0 > _const_math__bits__two32 * rhat + un1) {
		q1--;
		rhat += yn1;
		if (rhat >= _const_math__bits__two32) {
			break;
		}
	}
	u64 un21 = un32 * _const_math__bits__two32 + un1 - q1 * y;
	u64 q0 = un21 / yn1;
	rhat = un21 - q0 * yn1;
	while (q0 >= _const_math__bits__two32 || q0 * yn0 > _const_math__bits__two32 * rhat + un0) {
		q0--;
		rhat += yn1;
		if (rhat >= _const_math__bits__two32) {
			break;
		}
	}
	return (multi_return_u64_u64){.arg0=q1 * _const_math__bits__two32 + q0,.arg1=(un21 * _const_math__bits__two32 + un0 - q0 * y) >> s};
}

u32 math__bits__rem_32(u32 hi, u32 lo, u32 y) {
	return ((u32)((((((u64)(hi)) << 32) | ((u64)(lo)))) % ((u64)(y))));
}

u64 math__bits__rem_64(u64 hi, u64 lo, u64 y) {
	multi_return_u64_u64 mr_15079 = math__bits__div_64(hi % y, lo, y);
	u64 rem = mr_15079.arg1;
	return rem;
}

void _vinit() {
	builtin_init();
	vinit_string_literals();
	_const_init_capicity = 1 << _const_init_log_capicity;
	_const_max_load_factor = 0.8;
	_const_init_cap = _const_init_capicity - 2;
	_const_hash_mask = ((u32)(0x00FFFFFF));
	_const_probe_inc = ((u32)(0x01000000));
	_const_mid_index = _const_degree - 1;
	_const_max_size = 2 * _const_degree - 1;
	_const_children_bytes = sizeof(voidptr) * (_const_max_size + 1);
	_const_strconv__ftoa__ten_pow_table_32 = new_array_from_c_array(12, 12, sizeof(u32), (u32[12]){
		((u32)(1)), ((u32)(10)), ((u32)(100)), ((u32)(1000)), ((u32)(10000)), ((u32)(100000)), ((u32)(1000000)), ((u32)(10000000)), ((u32)(100000000)), ((u32)(1000000000)), ((u32)(10000000000)), ((u32)(100000000000)), 
});
	_const_strconv__ftoa__mantbits32 = ((u32)(23));
	_const_strconv__ftoa__expbits32 = ((u32)(8));
	_const_strconv__ftoa__bias32 = ((u32)(127));
	_const_strconv__ftoa__ten_pow_table_64 = new_array_from_c_array(20, 20, sizeof(u64), (u64[20]){
		((u64)(1)), ((u64)(10)), ((u64)(100)), ((u64)(1000)), ((u64)(10000)), ((u64)(100000)), ((u64)(1000000)), ((u64)(10000000)), ((u64)(100000000)), ((u64)(1000000000)), ((u64)(10000000000)), ((u64)(100000000000)), ((u64)(1000000000000)), ((u64)(10000000000000)), ((u64)(100000000000000)), ((u64)(1000000000000000)), ((u64)(10000000000000000)), ((u64)(100000000000000000)), ((u64)(1000000000000000000)), ((u64)(10000000000000000000)), 
});
	_const_strconv__ftoa__mantbits64 = ((u32)(52));
	_const_strconv__ftoa__expbits64 = ((u32)(11));
	_const_strconv__ftoa__bias64 = ((u32)(1023));
	_const_strconv__ftoa__powers_of_10 = new_array_from_c_array(18, 18, sizeof(u64), (u64[18]){
		((u64)(1e0)), ((u64)(1e1)), ((u64)(1e2)), ((u64)(1e3)), ((u64)(1e4)), ((u64)(1e5)), ((u64)(1e6)), ((u64)(1e7)), ((u64)(1e8)), ((u64)(1e9)), ((u64)(1e10)), ((u64)(1e11)), ((u64)(1e12)), ((u64)(1e13)), ((u64)(1e14)), ((u64)(1e15)), ((u64)(1e16)), ((u64)(1e17)), 
});
	_const_strconv__ftoa__pow5_split_32 = new_array_from_c_array(47, 47, sizeof(u64), (u64[47]){
		((u64)(1152921504606846976)), ((u64)(1441151880758558720)), ((u64)(1801439850948198400)), ((u64)(2251799813685248000)), ((u64)(1407374883553280000)), ((u64)(1759218604441600000)), ((u64)(2199023255552000000)), ((u64)(1374389534720000000)), ((u64)(1717986918400000000)), ((u64)(2147483648000000000)), ((u64)(1342177280000000000)), ((u64)(1677721600000000000)), ((u64)(2097152000000000000)), ((u64)(1310720000000000000)), ((u64)(1638400000000000000)), ((u64)(2048000000000000000)), ((u64)(1280000000000000000)), ((u64)(1600000000000000000)), ((u64)(2000000000000000000)), ((u64)(1250000000000000000)), ((u64)(1562500000000000000)), ((u64)(1953125000000000000)), ((u64)(1220703125000000000)), ((u64)(1525878906250000000)), ((u64)(1907348632812500000)), ((u64)(1192092895507812500)), ((u64)(1490116119384765625)), ((u64)(1862645149230957031)), ((u64)(1164153218269348144)), ((u64)(1455191522836685180)), ((u64)(1818989403545856475)), ((u64)(2273736754432320594)), ((u64)(1421085471520200371)), ((u64)(1776356839400250464)), ((u64)(2220446049250313080)), ((u64)(1387778780781445675)), ((u64)(1734723475976807094)), ((u64)(2168404344971008868)), ((u64)(1355252715606880542)), ((u64)(1694065894508600678)), ((u64)(2117582368135750847)), ((u64)(1323488980084844279)), ((u64)(1654361225106055349)), ((u64)(2067951531382569187)), ((u64)(1292469707114105741)), ((u64)(1615587133892632177)), ((u64)(2019483917365790221)), 
});
	_const_strconv__ftoa__pow5_inv_split_32 = new_array_from_c_array(31, 31, sizeof(u64), (u64[31]){
		((u64)(576460752303423489)), ((u64)(461168601842738791)), ((u64)(368934881474191033)), ((u64)(295147905179352826)), ((u64)(472236648286964522)), ((u64)(377789318629571618)), ((u64)(302231454903657294)), ((u64)(483570327845851670)), ((u64)(386856262276681336)), ((u64)(309485009821345069)), ((u64)(495176015714152110)), ((u64)(396140812571321688)), ((u64)(316912650057057351)), ((u64)(507060240091291761)), ((u64)(405648192073033409)), ((u64)(324518553658426727)), ((u64)(519229685853482763)), ((u64)(415383748682786211)), ((u64)(332306998946228969)), ((u64)(531691198313966350)), ((u64)(425352958651173080)), ((u64)(340282366920938464)), ((u64)(544451787073501542)), ((u64)(435561429658801234)), ((u64)(348449143727040987)), ((u64)(557518629963265579)), ((u64)(446014903970612463)), ((u64)(356811923176489971)), ((u64)(570899077082383953)), ((u64)(456719261665907162)), ((u64)(365375409332725730)), 
});
	_const_strconv__ftoa__pow5_split_64 = new_array_from_c_array(326, 326, sizeof(strconv__ftoa__Uint128), (strconv__ftoa__Uint128[326]){
		(strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x0100000000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x0140000000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x0190000000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01f4000000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x0138800000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x0186a00000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01e8480000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01312d0000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x017d784000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01dcd65000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x012a05f200000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x0174876e80000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01d1a94a20000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x012309ce54000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x016bcc41e9000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01c6bf5263400000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x011c37937e080000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x016345785d8a0000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01bc16d674ec8000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01158e460913d000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x015af1d78b58c400)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01b1ae4d6e2ef500)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x010f0cf064dd5920)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x0152d02c7e14af68)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01a784379d99db42)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4000000000000000)),
	.hi = ((u64)(0x0108b2a2c2802909)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9000000000000000)),
	.hi = ((u64)(0x014adf4b7320334b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7400000000000000)),
	.hi = ((u64)(0x019d971e4fe8401e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0880000000000000)),
	.hi = ((u64)(0x01027e72f1f12813)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcaa0000000000000)),
	.hi = ((u64)(0x01431e0fae6d7217)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbd48000000000000)),
	.hi = ((u64)(0x0193e5939a08ce9d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2c9a000000000000)),
	.hi = ((u64)(0x01f8def8808b0245)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3be0400000000000)),
	.hi = ((u64)(0x013b8b5b5056e16b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0ad8500000000000)),
	.hi = ((u64)(0x018a6e32246c99c6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8d8e640000000000)),
	.hi = ((u64)(0x01ed09bead87c037)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb878fe8000000000)),
	.hi = ((u64)(0x013426172c74d822)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x66973e2000000000)),
	.hi = ((u64)(0x01812f9cf7920e2b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x403d0da800000000)),
	.hi = ((u64)(0x01e17b84357691b6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe826288900000000)),
	.hi = ((u64)(0x012ced32a16a1b11)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x622fb2ab40000000)),
	.hi = ((u64)(0x0178287f49c4a1d6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfabb9f5610000000)),
	.hi = ((u64)(0x01d6329f1c35ca4b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7cb54395ca000000)),
	.hi = ((u64)(0x0125dfa371a19e6f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5be2947b3c800000)),
	.hi = ((u64)(0x016f578c4e0a060b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x32db399a0ba00000)),
	.hi = ((u64)(0x01cb2d6f618c878e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdfc9040047440000)),
	.hi = ((u64)(0x011efc659cf7d4b8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x17bb450059150000)),
	.hi = ((u64)(0x0166bb7f0435c9e7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xddaa16406f5a4000)),
	.hi = ((u64)(0x01c06a5ec5433c60)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8a8a4de845986800)),
	.hi = ((u64)(0x0118427b3b4a05bc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xad2ce16256fe8200)),
	.hi = ((u64)(0x015e531a0a1c872b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x987819baecbe2280)),
	.hi = ((u64)(0x01b5e7e08ca3a8f6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1f4b1014d3f6d590)),
	.hi = ((u64)(0x0111b0ec57e6499a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa71dd41a08f48af4)),
	.hi = ((u64)(0x01561d276ddfdc00)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd0e549208b31adb1)),
	.hi = ((u64)(0x01aba4714957d300)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x828f4db456ff0c8e)),
	.hi = ((u64)(0x010b46c6cdd6e3e0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa33321216cbecfb2)),
	.hi = ((u64)(0x014e1878814c9cd8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcbffe969c7ee839e)),
	.hi = ((u64)(0x01a19e96a19fc40e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3f7ff1e21cf51243)),
	.hi = ((u64)(0x0105031e2503da89)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8f5fee5aa43256d4)),
	.hi = ((u64)(0x014643e5ae44d12b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7337e9f14d3eec89)),
	.hi = ((u64)(0x0197d4df19d60576)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1005e46da08ea7ab)),
	.hi = ((u64)(0x01fdca16e04b86d4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8a03aec4845928cb)),
	.hi = ((u64)(0x013e9e4e4c2f3444)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xac849a75a56f72fd)),
	.hi = ((u64)(0x018e45e1df3b0155)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x17a5c1130ecb4fbd)),
	.hi = ((u64)(0x01f1d75a5709c1ab)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xeec798abe93f11d6)),
	.hi = ((u64)(0x013726987666190a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaa797ed6e38ed64b)),
	.hi = ((u64)(0x0184f03e93ff9f4d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1517de8c9c728bde)),
	.hi = ((u64)(0x01e62c4e38ff8721)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xad2eeb17e1c7976b)),
	.hi = ((u64)(0x012fdbb0e39fb474)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd87aa5ddda397d46)),
	.hi = ((u64)(0x017bd29d1c87a191)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4e994f5550c7dc97)),
	.hi = ((u64)(0x01dac74463a989f6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf11fd195527ce9de)),
	.hi = ((u64)(0x0128bc8abe49f639)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6d67c5faa71c2456)),
	.hi = ((u64)(0x0172ebad6ddc73c8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x88c1b77950e32d6c)),
	.hi = ((u64)(0x01cfa698c95390ba)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x957912abd28dfc63)),
	.hi = ((u64)(0x0121c81f7dd43a74)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbad75756c7317b7c)),
	.hi = ((u64)(0x016a3a275d494911)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x298d2d2c78fdda5b)),
	.hi = ((u64)(0x01c4c8b1349b9b56)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd9f83c3bcb9ea879)),
	.hi = ((u64)(0x011afd6ec0e14115)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x50764b4abe865297)),
	.hi = ((u64)(0x0161bcca7119915b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2493de1d6e27e73d)),
	.hi = ((u64)(0x01ba2bfd0d5ff5b2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x56dc6ad264d8f086)),
	.hi = ((u64)(0x01145b7e285bf98f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2c938586fe0f2ca8)),
	.hi = ((u64)(0x0159725db272f7f3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf7b866e8bd92f7d2)),
	.hi = ((u64)(0x01afcef51f0fb5ef)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfad34051767bdae3)),
	.hi = ((u64)(0x010de1593369d1b5)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x79881065d41ad19c)),
	.hi = ((u64)(0x015159af80444623)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x57ea147f49218603)),
	.hi = ((u64)(0x01a5b01b605557ac)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb6f24ccf8db4f3c1)),
	.hi = ((u64)(0x01078e111c3556cb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa4aee003712230b2)),
	.hi = ((u64)(0x014971956342ac7e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4dda98044d6abcdf)),
	.hi = ((u64)(0x019bcdfabc13579e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf0a89f02b062b60b)),
	.hi = ((u64)(0x010160bcb58c16c2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xacd2c6c35c7b638e)),
	.hi = ((u64)(0x0141b8ebe2ef1c73)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x98077874339a3c71)),
	.hi = ((u64)(0x01922726dbaae390)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbe0956914080cb8e)),
	.hi = ((u64)(0x01f6b0f092959c74)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf6c5d61ac8507f38)),
	.hi = ((u64)(0x013a2e965b9d81c8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x34774ba17a649f07)),
	.hi = ((u64)(0x0188ba3bf284e23b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x01951e89d8fdc6c8)),
	.hi = ((u64)(0x01eae8caef261aca)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x40fd3316279e9c3d)),
	.hi = ((u64)(0x0132d17ed577d0be)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd13c7fdbb186434c)),
	.hi = ((u64)(0x017f85de8ad5c4ed)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x458b9fd29de7d420)),
	.hi = ((u64)(0x01df67562d8b3629)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcb7743e3a2b0e494)),
	.hi = ((u64)(0x012ba095dc7701d9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3e5514dc8b5d1db9)),
	.hi = ((u64)(0x017688bb5394c250)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4dea5a13ae346527)),
	.hi = ((u64)(0x01d42aea2879f2e4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb0b2784c4ce0bf38)),
	.hi = ((u64)(0x01249ad2594c37ce)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5cdf165f6018ef06)),
	.hi = ((u64)(0x016dc186ef9f45c2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf416dbf7381f2ac8)),
	.hi = ((u64)(0x01c931e8ab871732)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd88e497a83137abd)),
	.hi = ((u64)(0x011dbf316b346e7f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xceb1dbd923d8596c)),
	.hi = ((u64)(0x01652efdc6018a1f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc25e52cf6cce6fc7)),
	.hi = ((u64)(0x01be7abd3781eca7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd97af3c1a40105dc)),
	.hi = ((u64)(0x01170cb642b133e8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0fd9b0b20d014754)),
	.hi = ((u64)(0x015ccfe3d35d80e3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd3d01cde90419929)),
	.hi = ((u64)(0x01b403dcc834e11b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6462120b1a28ffb9)),
	.hi = ((u64)(0x01108269fd210cb1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbd7a968de0b33fa8)),
	.hi = ((u64)(0x0154a3047c694fdd)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2cd93c3158e00f92)),
	.hi = ((u64)(0x01a9cbc59b83a3d5)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3c07c59ed78c09bb)),
	.hi = ((u64)(0x010a1f5b81324665)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8b09b7068d6f0c2a)),
	.hi = ((u64)(0x014ca732617ed7fe)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2dcc24c830cacf34)),
	.hi = ((u64)(0x019fd0fef9de8dfe)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdc9f96fd1e7ec180)),
	.hi = ((u64)(0x0103e29f5c2b18be)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x93c77cbc661e71e1)),
	.hi = ((u64)(0x0144db473335deee)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x38b95beb7fa60e59)),
	.hi = ((u64)(0x01961219000356aa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc6e7b2e65f8f91ef)),
	.hi = ((u64)(0x01fb969f40042c54)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfc50cfcffbb9bb35)),
	.hi = ((u64)(0x013d3e2388029bb4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3b6503c3faa82a03)),
	.hi = ((u64)(0x018c8dac6a0342a2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xca3e44b4f9523484)),
	.hi = ((u64)(0x01efb1178484134a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbe66eaf11bd360d2)),
	.hi = ((u64)(0x0135ceaeb2d28c0e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6e00a5ad62c83907)),
	.hi = ((u64)(0x0183425a5f872f12)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0980cf18bb7a4749)),
	.hi = ((u64)(0x01e412f0f768fad7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x65f0816f752c6c8d)),
	.hi = ((u64)(0x012e8bd69aa19cc6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xff6ca1cb527787b1)),
	.hi = ((u64)(0x017a2ecc414a03f7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xff47ca3e2715699d)),
	.hi = ((u64)(0x01d8ba7f519c84f5)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbf8cde66d86d6202)),
	.hi = ((u64)(0x0127748f9301d319)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2f7016008e88ba83)),
	.hi = ((u64)(0x017151b377c247e0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3b4c1b80b22ae923)),
	.hi = ((u64)(0x01cda62055b2d9d8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x250f91306f5ad1b6)),
	.hi = ((u64)(0x012087d4358fc827)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xee53757c8b318623)),
	.hi = ((u64)(0x0168a9c942f3ba30)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x29e852dbadfde7ac)),
	.hi = ((u64)(0x01c2d43b93b0a8bd)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3a3133c94cbeb0cc)),
	.hi = ((u64)(0x0119c4a53c4e6976)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc8bd80bb9fee5cff)),
	.hi = ((u64)(0x016035ce8b6203d3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbaece0ea87e9f43e)),
	.hi = ((u64)(0x01b843422e3a84c8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x74d40c9294f238a7)),
	.hi = ((u64)(0x01132a095ce492fd)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd2090fb73a2ec6d1)),
	.hi = ((u64)(0x0157f48bb41db7bc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x068b53a508ba7885)),
	.hi = ((u64)(0x01adf1aea12525ac)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8417144725748b53)),
	.hi = ((u64)(0x010cb70d24b7378b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x651cd958eed1ae28)),
	.hi = ((u64)(0x014fe4d06de5056e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfe640faf2a8619b2)),
	.hi = ((u64)(0x01a3de04895e46c9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3efe89cd7a93d00f)),
	.hi = ((u64)(0x01066ac2d5daec3e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcebe2c40d938c413)),
	.hi = ((u64)(0x014805738b51a74d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x426db7510f86f518)),
	.hi = ((u64)(0x019a06d06e261121)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc9849292a9b4592f)),
	.hi = ((u64)(0x0100444244d7cab4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfbe5b73754216f7a)),
	.hi = ((u64)(0x01405552d60dbd61)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7adf25052929cb59)),
	.hi = ((u64)(0x01906aa78b912cba)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1996ee4673743e2f)),
	.hi = ((u64)(0x01f485516e7577e9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaffe54ec0828a6dd)),
	.hi = ((u64)(0x0138d352e5096af1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1bfdea270a32d095)),
	.hi = ((u64)(0x018708279e4bc5ae)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa2fd64b0ccbf84ba)),
	.hi = ((u64)(0x01e8ca3185deb719)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x05de5eee7ff7b2f4)),
	.hi = ((u64)(0x01317e5ef3ab3270)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0755f6aa1ff59fb1)),
	.hi = ((u64)(0x017dddf6b095ff0c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x092b7454a7f3079e)),
	.hi = ((u64)(0x01dd55745cbb7ecf)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x65bb28b4e8f7e4c3)),
	.hi = ((u64)(0x012a5568b9f52f41)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbf29f2e22335ddf3)),
	.hi = ((u64)(0x0174eac2e8727b11)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2ef46f9aac035570)),
	.hi = ((u64)(0x01d22573a28f19d6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdd58c5c0ab821566)),
	.hi = ((u64)(0x0123576845997025)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x54aef730d6629ac0)),
	.hi = ((u64)(0x016c2d4256ffcc2f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x29dab4fd0bfb4170)),
	.hi = ((u64)(0x01c73892ecbfbf3b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfa28b11e277d08e6)),
	.hi = ((u64)(0x011c835bd3f7d784)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x38b2dd65b15c4b1f)),
	.hi = ((u64)(0x0163a432c8f5cd66)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc6df94bf1db35de7)),
	.hi = ((u64)(0x01bc8d3f7b3340bf)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdc4bbcf772901ab0)),
	.hi = ((u64)(0x0115d847ad000877)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd35eac354f34215c)),
	.hi = ((u64)(0x015b4e5998400a95)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x48365742a30129b4)),
	.hi = ((u64)(0x01b221effe500d3b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0d21f689a5e0ba10)),
	.hi = ((u64)(0x010f5535fef20845)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x506a742c0f58e894)),
	.hi = ((u64)(0x01532a837eae8a56)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe4851137132f22b9)),
	.hi = ((u64)(0x01a7f5245e5a2ceb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6ed32ac26bfd75b4)),
	.hi = ((u64)(0x0108f936baf85c13)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4a87f57306fcd321)),
	.hi = ((u64)(0x014b378469b67318)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5d29f2cfc8bc07e9)),
	.hi = ((u64)(0x019e056584240fde)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfa3a37c1dd7584f1)),
	.hi = ((u64)(0x0102c35f729689ea)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb8c8c5b254d2e62e)),
	.hi = ((u64)(0x014374374f3c2c65)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x26faf71eea079fb9)),
	.hi = ((u64)(0x01945145230b377f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf0b9b4e6a48987a8)),
	.hi = ((u64)(0x01f965966bce055e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5674111026d5f4c9)),
	.hi = ((u64)(0x013bdf7e0360c35b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2c111554308b71fb)),
	.hi = ((u64)(0x018ad75d8438f432)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb7155aa93cae4e7a)),
	.hi = ((u64)(0x01ed8d34e547313e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x326d58a9c5ecf10c)),
	.hi = ((u64)(0x013478410f4c7ec7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xff08aed437682d4f)),
	.hi = ((u64)(0x01819651531f9e78)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3ecada89454238a3)),
	.hi = ((u64)(0x01e1fbe5a7e78617)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x873ec895cb496366)),
	.hi = ((u64)(0x012d3d6f88f0b3ce)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x290e7abb3e1bbc3f)),
	.hi = ((u64)(0x01788ccb6b2ce0c2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb352196a0da2ab4f)),
	.hi = ((u64)(0x01d6affe45f818f2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb0134fe24885ab11)),
	.hi = ((u64)(0x01262dfeebbb0f97)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9c1823dadaa715d6)),
	.hi = ((u64)(0x016fb97ea6a9d37d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x031e2cd19150db4b)),
	.hi = ((u64)(0x01cba7de5054485d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x21f2dc02fad2890f)),
	.hi = ((u64)(0x011f48eaf234ad3a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaa6f9303b9872b53)),
	.hi = ((u64)(0x01671b25aec1d888)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd50b77c4a7e8f628)),
	.hi = ((u64)(0x01c0e1ef1a724eaa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc5272adae8f199d9)),
	.hi = ((u64)(0x01188d357087712a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7670f591a32e004f)),
	.hi = ((u64)(0x015eb082cca94d75)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd40d32f60bf98063)),
	.hi = ((u64)(0x01b65ca37fd3a0d2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc4883fd9c77bf03e)),
	.hi = ((u64)(0x0111f9e62fe44483)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb5aa4fd0395aec4d)),
	.hi = ((u64)(0x0156785fbbdd55a4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe314e3c447b1a760)),
	.hi = ((u64)(0x01ac1677aad4ab0d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaded0e5aaccf089c)),
	.hi = ((u64)(0x010b8e0acac4eae8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd96851f15802cac3)),
	.hi = ((u64)(0x014e718d7d7625a2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8fc2666dae037d74)),
	.hi = ((u64)(0x01a20df0dcd3af0b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x39d980048cc22e68)),
	.hi = ((u64)(0x010548b68a044d67)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x084fe005aff2ba03)),
	.hi = ((u64)(0x01469ae42c8560c1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4a63d8071bef6883)),
	.hi = ((u64)(0x0198419d37a6b8f1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9cfcce08e2eb42a4)),
	.hi = ((u64)(0x01fe52048590672d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x821e00c58dd309a7)),
	.hi = ((u64)(0x013ef342d37a407c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa2a580f6f147cc10)),
	.hi = ((u64)(0x018eb0138858d09b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8b4ee134ad99bf15)),
	.hi = ((u64)(0x01f25c186a6f04c2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x97114cc0ec80176d)),
	.hi = ((u64)(0x0137798f428562f9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfcd59ff127a01d48)),
	.hi = ((u64)(0x018557f31326bbb7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfc0b07ed7188249a)),
	.hi = ((u64)(0x01e6adefd7f06aa5)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbd86e4f466f516e0)),
	.hi = ((u64)(0x01302cb5e6f642a7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xace89e3180b25c98)),
	.hi = ((u64)(0x017c37e360b3d351)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1822c5bde0def3be)),
	.hi = ((u64)(0x01db45dc38e0c826)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcf15bb96ac8b5857)),
	.hi = ((u64)(0x01290ba9a38c7d17)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc2db2a7c57ae2e6d)),
	.hi = ((u64)(0x01734e940c6f9c5d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3391f51b6d99ba08)),
	.hi = ((u64)(0x01d022390f8b8375)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x403b393124801445)),
	.hi = ((u64)(0x01221563a9b73229)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x904a077d6da01956)),
	.hi = ((u64)(0x016a9abc9424feb3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x745c895cc9081fac)),
	.hi = ((u64)(0x01c5416bb92e3e60)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x48b9d5d9fda513cb)),
	.hi = ((u64)(0x011b48e353bce6fc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5ae84b507d0e58be)),
	.hi = ((u64)(0x01621b1c28ac20bb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x31a25e249c51eeee)),
	.hi = ((u64)(0x01baa1e332d728ea)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5f057ad6e1b33554)),
	.hi = ((u64)(0x0114a52dffc67992)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf6c6d98c9a2002aa)),
	.hi = ((u64)(0x0159ce797fb817f6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb4788fefc0a80354)),
	.hi = ((u64)(0x01b04217dfa61df4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf0cb59f5d8690214)),
	.hi = ((u64)(0x010e294eebc7d2b8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2cfe30734e83429a)),
	.hi = ((u64)(0x0151b3a2a6b9c767)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf83dbc9022241340)),
	.hi = ((u64)(0x01a6208b50683940)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9b2695da15568c08)),
	.hi = ((u64)(0x0107d457124123c8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc1f03b509aac2f0a)),
	.hi = ((u64)(0x0149c96cd6d16cba)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x726c4a24c1573acd)),
	.hi = ((u64)(0x019c3bc80c85c7e9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe783ae56f8d684c0)),
	.hi = ((u64)(0x0101a55d07d39cf1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x616499ecb70c25f0)),
	.hi = ((u64)(0x01420eb449c8842e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf9bdc067e4cf2f6c)),
	.hi = ((u64)(0x019292615c3aa539)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x782d3081de02fb47)),
	.hi = ((u64)(0x01f736f9b3494e88)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4b1c3e512ac1dd0c)),
	.hi = ((u64)(0x013a825c100dd115)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9de34de57572544f)),
	.hi = ((u64)(0x018922f31411455a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x455c215ed2cee963)),
	.hi = ((u64)(0x01eb6bafd91596b1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcb5994db43c151de)),
	.hi = ((u64)(0x0133234de7ad7e2e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7e2ffa1214b1a655)),
	.hi = ((u64)(0x017fec216198ddba)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1dbbf89699de0feb)),
	.hi = ((u64)(0x01dfe729b9ff1529)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb2957b5e202ac9f3)),
	.hi = ((u64)(0x012bf07a143f6d39)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1f3ada35a8357c6f)),
	.hi = ((u64)(0x0176ec98994f4888)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x270990c31242db8b)),
	.hi = ((u64)(0x01d4a7bebfa31aaa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5865fa79eb69c937)),
	.hi = ((u64)(0x0124e8d737c5f0aa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xee7f791866443b85)),
	.hi = ((u64)(0x016e230d05b76cd4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2a1f575e7fd54a66)),
	.hi = ((u64)(0x01c9abd04725480a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5a53969b0fe54e80)),
	.hi = ((u64)(0x011e0b622c774d06)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf0e87c41d3dea220)),
	.hi = ((u64)(0x01658e3ab7952047)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xed229b5248d64aa8)),
	.hi = ((u64)(0x01bef1c9657a6859)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3435a1136d85eea9)),
	.hi = ((u64)(0x0117571ddf6c8138)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4143095848e76a53)),
	.hi = ((u64)(0x015d2ce55747a186)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd193cbae5b2144e8)),
	.hi = ((u64)(0x01b4781ead1989e7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe2fc5f4cf8f4cb11)),
	.hi = ((u64)(0x0110cb132c2ff630)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1bbb77203731fdd5)),
	.hi = ((u64)(0x0154fdd7f73bf3bd)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x62aa54e844fe7d4a)),
	.hi = ((u64)(0x01aa3d4df50af0ac)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbdaa75112b1f0e4e)),
	.hi = ((u64)(0x010a6650b926d66b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xad15125575e6d1e2)),
	.hi = ((u64)(0x014cffe4e7708c06)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x585a56ead360865b)),
	.hi = ((u64)(0x01a03fde214caf08)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x37387652c41c53f8)),
	.hi = ((u64)(0x010427ead4cfed65)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x850693e7752368f7)),
	.hi = ((u64)(0x014531e58a03e8be)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x264838e1526c4334)),
	.hi = ((u64)(0x01967e5eec84e2ee)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xafda4719a7075402)),
	.hi = ((u64)(0x01fc1df6a7a61ba9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0de86c7008649481)),
	.hi = ((u64)(0x013d92ba28c7d14a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9162878c0a7db9a1)),
	.hi = ((u64)(0x018cf768b2f9c59c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb5bb296f0d1d280a)),
	.hi = ((u64)(0x01f03542dfb83703)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5194f9e568323906)),
	.hi = ((u64)(0x01362149cbd32262)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe5fa385ec23ec747)),
	.hi = ((u64)(0x0183a99c3ec7eafa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9f78c67672ce7919)),
	.hi = ((u64)(0x01e494034e79e5b9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x03ab7c0a07c10bb0)),
	.hi = ((u64)(0x012edc82110c2f94)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x04965b0c89b14e9c)),
	.hi = ((u64)(0x017a93a2954f3b79)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x45bbf1cfac1da243)),
	.hi = ((u64)(0x01d9388b3aa30a57)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8b957721cb92856a)),
	.hi = ((u64)(0x0127c35704a5e676)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2e7ad4ea3e7726c4)),
	.hi = ((u64)(0x0171b42cc5cf6014)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3a198a24ce14f075)),
	.hi = ((u64)(0x01ce2137f7433819)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc44ff65700cd1649)),
	.hi = ((u64)(0x0120d4c2fa8a030f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb563f3ecc1005bdb)),
	.hi = ((u64)(0x016909f3b92c83d3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa2bcf0e7f14072d2)),
	.hi = ((u64)(0x01c34c70a777a4c8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x65b61690f6c847c3)),
	.hi = ((u64)(0x011a0fc668aac6fd)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbf239c35347a59b4)),
	.hi = ((u64)(0x016093b802d578bc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xeeec83428198f021)),
	.hi = ((u64)(0x01b8b8a6038ad6eb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7553d20990ff9615)),
	.hi = ((u64)(0x01137367c236c653)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x52a8c68bf53f7b9a)),
	.hi = ((u64)(0x01585041b2c477e8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6752f82ef28f5a81)),
	.hi = ((u64)(0x01ae64521f7595e2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8093db1d57999890)),
	.hi = ((u64)(0x010cfeb353a97dad)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe0b8d1e4ad7ffeb4)),
	.hi = ((u64)(0x01503e602893dd18)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x18e7065dd8dffe62)),
	.hi = ((u64)(0x01a44df832b8d45f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6f9063faa78bfefd)),
	.hi = ((u64)(0x0106b0bb1fb384bb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4b747cf9516efebc)),
	.hi = ((u64)(0x01485ce9e7a065ea)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xde519c37a5cabe6b)),
	.hi = ((u64)(0x019a742461887f64)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0af301a2c79eb703)),
	.hi = ((u64)(0x01008896bcf54f9f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcdafc20b798664c4)),
	.hi = ((u64)(0x0140aabc6c32a386)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x811bb28e57e7fdf5)),
	.hi = ((u64)(0x0190d56b873f4c68)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa1629f31ede1fd72)),
	.hi = ((u64)(0x01f50ac6690f1f82)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa4dda37f34ad3e67)),
	.hi = ((u64)(0x013926bc01a973b1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0e150c5f01d88e01)),
	.hi = ((u64)(0x0187706b0213d09e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x919a4f76c24eb181)),
	.hi = ((u64)(0x01e94c85c298c4c5)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7b0071aa39712ef1)),
	.hi = ((u64)(0x0131cfd3999f7afb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x59c08e14c7cd7aad)),
	.hi = ((u64)(0x017e43c8800759ba)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf030b199f9c0d958)),
	.hi = ((u64)(0x01ddd4baa0093028)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x961e6f003c1887d7)),
	.hi = ((u64)(0x012aa4f4a405be19)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfba60ac04b1ea9cd)),
	.hi = ((u64)(0x01754e31cd072d9f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfa8f8d705de65440)),
	.hi = ((u64)(0x01d2a1be4048f907)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfc99b8663aaff4a8)),
	.hi = ((u64)(0x0123a516e82d9ba4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3bc0267fc95bf1d2)),
	.hi = ((u64)(0x016c8e5ca239028e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcab0301fbbb2ee47)),
	.hi = ((u64)(0x01c7b1f3cac74331)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1eae1e13d54fd4ec)),
	.hi = ((u64)(0x011ccf385ebc89ff)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe659a598caa3ca27)),
	.hi = ((u64)(0x01640306766bac7e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9ff00efefd4cbcb1)),
	.hi = ((u64)(0x01bd03c81406979e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x23f6095f5e4ff5ef)),
	.hi = ((u64)(0x0116225d0c841ec3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xecf38bb735e3f36a)),
	.hi = ((u64)(0x015baaf44fa52673)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe8306ea5035cf045)),
	.hi = ((u64)(0x01b295b1638e7010)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x911e4527221a162b)),
	.hi = ((u64)(0x010f9d8ede39060a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3565d670eaa09bb6)),
	.hi = ((u64)(0x015384f295c7478d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x82bf4c0d2548c2a3)),
	.hi = ((u64)(0x01a8662f3b391970)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x51b78f88374d79a6)),
	.hi = ((u64)(0x01093fdd8503afe6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe625736a4520d810)),
	.hi = ((u64)(0x014b8fd4e6449bdf)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdfaed044d6690e14)),
	.hi = ((u64)(0x019e73ca1fd5c2d7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xebcd422b0601a8cc)),
	.hi = ((u64)(0x0103085e53e599c6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa6c092b5c78212ff)),
	.hi = ((u64)(0x0143ca75e8df0038)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd070b763396297bf)),
	.hi = ((u64)(0x0194bd136316c046)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x848ce53c07bb3daf)),
	.hi = ((u64)(0x01f9ec583bdc7058)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x52d80f4584d5068d)),
	.hi = ((u64)(0x013c33b72569c637)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x278e1316e60a4831)),
	.hi = ((u64)(0x018b40a4eec437c5)),
}, 
});
	_const_strconv__ftoa__pow5_inv_split_64 = new_array_from_c_array(292, 292, sizeof(strconv__ftoa__Uint128), (strconv__ftoa__Uint128[292]){
		(strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000001)),
	.hi = ((u64)(0x0400000000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3333333333333334)),
	.hi = ((u64)(0x0333333333333333)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x28f5c28f5c28f5c3)),
	.hi = ((u64)(0x028f5c28f5c28f5c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xed916872b020c49c)),
	.hi = ((u64)(0x020c49ba5e353f7c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaf4f0d844d013a93)),
	.hi = ((u64)(0x0346dc5d63886594)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8c3f3e0370cdc876)),
	.hi = ((u64)(0x029f16b11c6d1e10)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd698fe69270b06c5)),
	.hi = ((u64)(0x0218def416bdb1a6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf0f4ca41d811a46e)),
	.hi = ((u64)(0x035afe535795e90a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf3f70834acdae9f1)),
	.hi = ((u64)(0x02af31dc4611873b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5cc5a02a23e254c1)),
	.hi = ((u64)(0x0225c17d04dad296)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfad5cd10396a2135)),
	.hi = ((u64)(0x036f9bfb3af7b756)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfbde3da69454e75e)),
	.hi = ((u64)(0x02bfaffc2f2c92ab)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2fe4fe1edd10b918)),
	.hi = ((u64)(0x0232f33025bd4223)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4ca19697c81ac1bf)),
	.hi = ((u64)(0x0384b84d092ed038)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3d4e1213067bce33)),
	.hi = ((u64)(0x02d09370d4257360)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x643e74dc052fd829)),
	.hi = ((u64)(0x024075f3dceac2b3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6d30baf9a1e626a7)),
	.hi = ((u64)(0x039a5652fb113785)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2426fbfae7eb5220)),
	.hi = ((u64)(0x02e1dea8c8da92d1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1cebfcc8b9890e80)),
	.hi = ((u64)(0x024e4bba3a487574)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x94acc7a78f41b0cc)),
	.hi = ((u64)(0x03b07929f6da5586)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaa23d2ec729af3d7)),
	.hi = ((u64)(0x02f394219248446b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbb4fdbf05baf2979)),
	.hi = ((u64)(0x025c768141d369ef)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc54c931a2c4b758d)),
	.hi = ((u64)(0x03c7240202ebdcb2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9dd6dc14f03c5e0b)),
	.hi = ((u64)(0x0305b66802564a28)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4b1249aa59c9e4d6)),
	.hi = ((u64)(0x026af8533511d4ed)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x44ea0f76f60fd489)),
	.hi = ((u64)(0x03de5a1ebb4fbb15)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6a54d92bf80caa07)),
	.hi = ((u64)(0x0318481895d96277)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x21dd7a89933d54d2)),
	.hi = ((u64)(0x0279d346de4781f9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x362f2a75b8622150)),
	.hi = ((u64)(0x03f61ed7ca0c0328)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf825bb91604e810d)),
	.hi = ((u64)(0x032b4bdfd4d668ec)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc684960de6a5340b)),
	.hi = ((u64)(0x0289097fdd7853f0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd203ab3e521dc33c)),
	.hi = ((u64)(0x02073accb12d0ff3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe99f7863b696052c)),
	.hi = ((u64)(0x033ec47ab514e652)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x87b2c6b62bab3757)),
	.hi = ((u64)(0x02989d2ef743eb75)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd2f56bc4efbc2c45)),
	.hi = ((u64)(0x0213b0f25f69892a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1e55793b192d13a2)),
	.hi = ((u64)(0x0352b4b6ff0f41de)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4b77942f475742e8)),
	.hi = ((u64)(0x02a8909265a5ce4b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd5f9435905df68ba)),
	.hi = ((u64)(0x022073a8515171d5)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x565b9ef4d6324129)),
	.hi = ((u64)(0x03671f73b54f1c89)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdeafb25d78283421)),
	.hi = ((u64)(0x02b8e5f62aa5b06d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x188c8eb12cecf681)),
	.hi = ((u64)(0x022d84c4eeeaf38b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8dadb11b7b14bd9b)),
	.hi = ((u64)(0x037c07a17e44b8de)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7157c0e2c8dd647c)),
	.hi = ((u64)(0x02c99fb46503c718)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8ddfcd823a4ab6ca)),
	.hi = ((u64)(0x023ae629ea696c13)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1632e269f6ddf142)),
	.hi = ((u64)(0x0391704310a8acec)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x44f581ee5f17f435)),
	.hi = ((u64)(0x02dac035a6ed5723)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x372ace584c1329c4)),
	.hi = ((u64)(0x024899c4858aac1c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbeaae3c079b842d3)),
	.hi = ((u64)(0x03a75c6da27779c6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6555830061603576)),
	.hi = ((u64)(0x02ec49f14ec5fb05)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb7779c004de6912b)),
	.hi = ((u64)(0x0256a18dd89e626a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf258f99a163db512)),
	.hi = ((u64)(0x03bdcf495a9703dd)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5b7a614811caf741)),
	.hi = ((u64)(0x02fe3f6de212697e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaf951aa00e3bf901)),
	.hi = ((u64)(0x0264ff8b1b41edfe)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7f54f7667d2cc19b)),
	.hi = ((u64)(0x03d4cc11c5364997)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x32aa5f8530f09ae3)),
	.hi = ((u64)(0x0310a3416a91d479)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf55519375a5a1582)),
	.hi = ((u64)(0x0273b5cdeedb1060)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbbbb5b8bc3c3559d)),
	.hi = ((u64)(0x03ec56164af81a34)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2fc916096969114a)),
	.hi = ((u64)(0x03237811d593482a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x596dab3ababa743c)),
	.hi = ((u64)(0x0282c674aadc39bb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x478aef622efb9030)),
	.hi = ((u64)(0x0202385d557cfafc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd8de4bd04b2c19e6)),
	.hi = ((u64)(0x0336c0955594c4c6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xad7ea30d08f014b8)),
	.hi = ((u64)(0x029233aaaadd6a38)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x24654f3da0c01093)),
	.hi = ((u64)(0x020e8fbbbbe454fa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3a3bb1fc346680eb)),
	.hi = ((u64)(0x034a7f92c63a2190)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x94fc8e635d1ecd89)),
	.hi = ((u64)(0x02a1ffa89e94e7a6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaa63a51c4a7f0ad4)),
	.hi = ((u64)(0x021b32ed4baa52eb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdd6c3b607731aaed)),
	.hi = ((u64)(0x035eb7e212aa1e45)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1789c919f8f488bd)),
	.hi = ((u64)(0x02b22cb4dbbb4b6b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xac6e3a7b2d906d64)),
	.hi = ((u64)(0x022823c3e2fc3c55)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x13e390c515b3e23a)),
	.hi = ((u64)(0x03736c6c9e606089)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdcb60d6a77c31b62)),
	.hi = ((u64)(0x02c2bd23b1e6b3a0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7d5e7121f968e2b5)),
	.hi = ((u64)(0x0235641c8e52294d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc8971b698f0e3787)),
	.hi = ((u64)(0x0388a02db0837548)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa078e2bad8d82c6c)),
	.hi = ((u64)(0x02d3b357c0692aa0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe6c71bc8ad79bd24)),
	.hi = ((u64)(0x0242f5dfcd20eee6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0ad82c7448c2c839)),
	.hi = ((u64)(0x039e5632e1ce4b0b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3be023903a356cfa)),
	.hi = ((u64)(0x02e511c24e3ea26f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2fe682d9c82abd95)),
	.hi = ((u64)(0x0250db01d8321b8c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4ca4048fa6aac8ee)),
	.hi = ((u64)(0x03b4919c8d1cf8e0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3d5003a61eef0725)),
	.hi = ((u64)(0x02f6dae3a4172d80)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9773361e7f259f51)),
	.hi = ((u64)(0x025f1582e9ac2466)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8beb89ca6508fee8)),
	.hi = ((u64)(0x03cb559e42ad070a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6fefa16eb73a6586)),
	.hi = ((u64)(0x0309114b688a6c08)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf3261abef8fb846b)),
	.hi = ((u64)(0x026da76f86d52339)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x51d691318e5f3a45)),
	.hi = ((u64)(0x03e2a57f3e21d1f6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0e4540f471e5c837)),
	.hi = ((u64)(0x031bb798fe8174c5)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd8376729f4b7d360)),
	.hi = ((u64)(0x027c92e0cb9ac3d0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf38bd84321261eff)),
	.hi = ((u64)(0x03fa849adf5e061a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x293cad0280eb4bff)),
	.hi = ((u64)(0x032ed07be5e4d1af)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xedca240200bc3ccc)),
	.hi = ((u64)(0x028bd9fcb7ea4158)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbe3b50019a3030a4)),
	.hi = ((u64)(0x02097b309321cde0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc9f88002904d1a9f)),
	.hi = ((u64)(0x03425eb41e9c7c9a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3b2d3335403daee6)),
	.hi = ((u64)(0x029b7ef67ee396e2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x95bdc291003158b8)),
	.hi = ((u64)(0x0215ff2b98b6124e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x892f9db4cd1bc126)),
	.hi = ((u64)(0x035665128df01d4a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x07594af70a7c9a85)),
	.hi = ((u64)(0x02ab840ed7f34aa2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6c476f2c0863aed1)),
	.hi = ((u64)(0x0222d00bdff5d54e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x13a57eacda3917b4)),
	.hi = ((u64)(0x036ae67966562217)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0fb7988a482dac90)),
	.hi = ((u64)(0x02bbeb9451de81ac)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd95fad3b6cf156da)),
	.hi = ((u64)(0x022fefa9db1867bc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf565e1f8ae4ef15c)),
	.hi = ((u64)(0x037fe5dc91c0a5fa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x911e4e608b725ab0)),
	.hi = ((u64)(0x02ccb7e3a7cd5195)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xda7ea51a0928488d)),
	.hi = ((u64)(0x023d5fe9530aa7aa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf7310829a8407415)),
	.hi = ((u64)(0x039566421e7772aa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2c2739baed005cde)),
	.hi = ((u64)(0x02ddeb68185f8eef)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbcec2e2f24004a4b)),
	.hi = ((u64)(0x024b22b9ad193f25)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x94ad16b1d333aa11)),
	.hi = ((u64)(0x03ab6ac2ae8ecb6f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaa241227dc2954db)),
	.hi = ((u64)(0x02ef889bbed8a2bf)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x54e9a81fe35443e2)),
	.hi = ((u64)(0x02593a163246e899)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2175d9cc9eed396a)),
	.hi = ((u64)(0x03c1f689ea0b0dc2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe7917b0a18bdc788)),
	.hi = ((u64)(0x03019207ee6f3e34)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb9412f3b46fe393a)),
	.hi = ((u64)(0x0267a8065858fe90)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf535185ed7fd285c)),
	.hi = ((u64)(0x03d90cd6f3c1974d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc42a79e57997537d)),
	.hi = ((u64)(0x03140a458fce12a4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x03552e512e12a931)),
	.hi = ((u64)(0x02766e9e0ca4dbb7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9eeeb081e3510eb4)),
	.hi = ((u64)(0x03f0b0fce107c5f1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4bf226ce4f740bc3)),
	.hi = ((u64)(0x0326f3fd80d304c1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa3281f0b72c33c9c)),
	.hi = ((u64)(0x02858ffe00a8d09a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1c2018d5f568fd4a)),
	.hi = ((u64)(0x020473319a20a6e2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf9ccf48988a7fba9)),
	.hi = ((u64)(0x033a51e8f69aa49c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfb0a5d3ad3b99621)),
	.hi = ((u64)(0x02950e53f87bb6e3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2f3b7dc8a96144e7)),
	.hi = ((u64)(0x0210d8432d2fc583)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe52bfc7442353b0c)),
	.hi = ((u64)(0x034e26d1e1e608d1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb756639034f76270)),
	.hi = ((u64)(0x02a4ebdb1b1e6d74)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2c451c735d92b526)),
	.hi = ((u64)(0x021d897c15b1f12a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x13a1c71efc1deea3)),
	.hi = ((u64)(0x0362759355e981dd)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x761b05b2634b2550)),
	.hi = ((u64)(0x02b52adc44bace4a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x91af37c1e908eaa6)),
	.hi = ((u64)(0x022a88b036fbd83b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x82b1f2cfdb417770)),
	.hi = ((u64)(0x03774119f192f392)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcef4c23fe29ac5f3)),
	.hi = ((u64)(0x02c5cdae5adbf60e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3f2a34ffe87bd190)),
	.hi = ((u64)(0x0237d7beaf165e72)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x984387ffda5fb5b2)),
	.hi = ((u64)(0x038c8c644b56fd83)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe0360666484c915b)),
	.hi = ((u64)(0x02d6d6b6a2abfe02)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x802b3851d3707449)),
	.hi = ((u64)(0x024578921bbccb35)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x99dec082ebe72075)),
	.hi = ((u64)(0x03a25a835f947855)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xae4bcd358985b391)),
	.hi = ((u64)(0x02e8486919439377)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbea30a913ad15c74)),
	.hi = ((u64)(0x02536d20e102dc5f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfdd1aa81f7b560b9)),
	.hi = ((u64)(0x03b8ae9b019e2d65)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x97daeece5fc44d61)),
	.hi = ((u64)(0x02fa2548ce182451)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdfe258a51969d781)),
	.hi = ((u64)(0x0261b76d71ace9da)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x996a276e8f0fbf34)),
	.hi = ((u64)(0x03cf8be24f7b0fc4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe121b9253f3fcc2a)),
	.hi = ((u64)(0x030c6fe83f95a636)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb41afa8432997022)),
	.hi = ((u64)(0x02705986994484f8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xecf7f739ea8f19cf)),
	.hi = ((u64)(0x03e6f5a4286da18d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x23f99294bba5ae40)),
	.hi = ((u64)(0x031f2ae9b9f14e0b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4ffadbaa2fb7be99)),
	.hi = ((u64)(0x027f5587c7f43e6f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7ff7c5dd1925fdc2)),
	.hi = ((u64)(0x03feef3fa6539718)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xccc637e4141e649b)),
	.hi = ((u64)(0x033258ffb842df46)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd704f983434b83af)),
	.hi = ((u64)(0x028ead9960357f6b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x126a6135cf6f9c8c)),
	.hi = ((u64)(0x020bbe144cf79923)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x83dd685618b29414)),
	.hi = ((u64)(0x0345fced47f28e9e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9cb12044e08edcdd)),
	.hi = ((u64)(0x029e63f1065ba54b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x16f419d0b3a57d7d)),
	.hi = ((u64)(0x02184ff405161dd6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8b20294dec3bfbfb)),
	.hi = ((u64)(0x035a19866e89c956)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3c19baa4bcfcc996)),
	.hi = ((u64)(0x02ae7ad1f207d445)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc9ae2eea30ca3adf)),
	.hi = ((u64)(0x02252f0e5b39769d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0f7d17dd1add2afd)),
	.hi = ((u64)(0x036eb1b091f58a96)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3f97464a7be42264)),
	.hi = ((u64)(0x02bef48d41913bab)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcc790508631ce850)),
	.hi = ((u64)(0x02325d3dce0dc955)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe0c1a1a704fb0d4d)),
	.hi = ((u64)(0x0383c862e3494222)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4d67b4859d95a43e)),
	.hi = ((u64)(0x02cfd3824f6dce82)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x711fc39e17aae9cb)),
	.hi = ((u64)(0x023fdc683f8b0b9b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe832d2968c44a945)),
	.hi = ((u64)(0x039960a6cc11ac2b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xecf575453d03ba9e)),
	.hi = ((u64)(0x02e11a1f09a7bcef)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x572ac4376402fbb1)),
	.hi = ((u64)(0x024dae7f3aec9726)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x58446d256cd192b5)),
	.hi = ((u64)(0x03af7d985e47583d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x79d0575123dadbc4)),
	.hi = ((u64)(0x02f2cae04b6c4697)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x94a6ac40e97be303)),
	.hi = ((u64)(0x025bd5803c569edf)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8771139b0f2c9e6c)),
	.hi = ((u64)(0x03c62266c6f0fe32)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9f8da948d8f07ebd)),
	.hi = ((u64)(0x0304e85238c0cb5b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe60aedd3e0c06564)),
	.hi = ((u64)(0x026a5374fa33d5e2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa344afb9679a3bd2)),
	.hi = ((u64)(0x03dd5254c3862304)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe903bfc78614fca8)),
	.hi = ((u64)(0x031775109c6b4f36)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xba6966393810ca20)),
	.hi = ((u64)(0x02792a73b055d8f8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2a423d2859b4769a)),
	.hi = ((u64)(0x03f510b91a22f4c1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xee9b642047c39215)),
	.hi = ((u64)(0x032a73c7481bf700)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbee2b680396941aa)),
	.hi = ((u64)(0x02885c9f6ce32c00)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xff1bc53361210155)),
	.hi = ((u64)(0x0206b07f8a4f5666)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x31c6085235019bbb)),
	.hi = ((u64)(0x033de73276e5570b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x27d1a041c4014963)),
	.hi = ((u64)(0x0297ec285f1ddf3c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xeca7b367d0010782)),
	.hi = ((u64)(0x021323537f4b18fc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xadd91f0c8001a59d)),
	.hi = ((u64)(0x0351d21f3211c194)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf17a7f3d3334847e)),
	.hi = ((u64)(0x02a7db4c280e3476)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x279532975c2a0398)),
	.hi = ((u64)(0x021fe2a3533e905f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd8eeb75893766c26)),
	.hi = ((u64)(0x0366376bb8641a31)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7a5892ad42c52352)),
	.hi = ((u64)(0x02b82c562d1ce1c1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfb7a0ef102374f75)),
	.hi = ((u64)(0x022cf044f0e3e7cd)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc59017e8038bb254)),
	.hi = ((u64)(0x037b1a07e7d30c7c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x37a67986693c8eaa)),
	.hi = ((u64)(0x02c8e19feca8d6ca)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf951fad1edca0bbb)),
	.hi = ((u64)(0x023a4e198a20abd4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x28832ae97c76792b)),
	.hi = ((u64)(0x03907cf5a9cddfbb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2068ef21305ec756)),
	.hi = ((u64)(0x02d9fd9154a4b2fc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x19ed8c1a8d189f78)),
	.hi = ((u64)(0x0247fe0ddd508f30)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5caf4690e1c0ff26)),
	.hi = ((u64)(0x03a66349621a7eb3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4a25d20d81673285)),
	.hi = ((u64)(0x02eb82a11b48655c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3b5174d79ab8f537)),
	.hi = ((u64)(0x0256021a7c39eab0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x921bee25c45b21f1)),
	.hi = ((u64)(0x03bcd02a605caab3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdb498b5169e2818e)),
	.hi = ((u64)(0x02fd735519e3bbc2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x15d46f7454b53472)),
	.hi = ((u64)(0x02645c4414b62fcf)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xefba4bed545520b6)),
	.hi = ((u64)(0x03d3c6d35456b2e4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf2fb6ff110441a2b)),
	.hi = ((u64)(0x030fd242a9def583)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8f2f8cc0d9d014ef)),
	.hi = ((u64)(0x02730e9bbb18c469)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb1e5ae015c80217f)),
	.hi = ((u64)(0x03eb4a92c4f46d75)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc1848b344a001acc)),
	.hi = ((u64)(0x0322a20f03f6bdf7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xce03a2903b3348a3)),
	.hi = ((u64)(0x02821b3f365efe5f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd802e873628f6d4f)),
	.hi = ((u64)(0x0201af65c518cb7f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x599e40b89db2487f)),
	.hi = ((u64)(0x0335e56fa1c14599)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe14b66fa17c1d399)),
	.hi = ((u64)(0x029184594e3437ad)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x81091f2e7967dc7a)),
	.hi = ((u64)(0x020e037aa4f692f1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9b41cb7d8f0c93f6)),
	.hi = ((u64)(0x03499f2aa18a84b5)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaf67d5fe0c0a0ff8)),
	.hi = ((u64)(0x02a14c221ad536f7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf2b977fe70080cc7)),
	.hi = ((u64)(0x021aa34e7bddc592)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1df58cca4cd9ae0b)),
	.hi = ((u64)(0x035dd2172c9608eb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe4c470a1d7148b3c)),
	.hi = ((u64)(0x02b174df56de6d88)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x83d05a1b1276d5ca)),
	.hi = ((u64)(0x022790b2abe5246d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9fb3c35e83f1560f)),
	.hi = ((u64)(0x0372811ddfd50715)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb2f635e5365aab3f)),
	.hi = ((u64)(0x02c200e4b310d277)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf591c4b75eaeef66)),
	.hi = ((u64)(0x0234cd83c273db92)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xef4fa125644b18a3)),
	.hi = ((u64)(0x0387af39371fc5b7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8c3fb41de9d5ad4f)),
	.hi = ((u64)(0x02d2f2942c196af9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3cffc34b2177bdd9)),
	.hi = ((u64)(0x02425ba9bce12261)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x94cc6bab68bf9628)),
	.hi = ((u64)(0x039d5f75fb01d09b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x10a38955ed6611b9)),
	.hi = ((u64)(0x02e44c5e6267da16)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xda1c6dde5784dafb)),
	.hi = ((u64)(0x02503d184eb97b44)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf693e2fd58d49191)),
	.hi = ((u64)(0x03b394f3b128c53a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc5431bfde0aa0e0e)),
	.hi = ((u64)(0x02f610c2f4209dc8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6a9c1664b3bb3e72)),
	.hi = ((u64)(0x025e73cf29b3b16d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x10f9bd6dec5eca4f)),
	.hi = ((u64)(0x03ca52e50f85e8af)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xda616457f04bd50c)),
	.hi = ((u64)(0x03084250d937ed58)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe1e783798d09773d)),
	.hi = ((u64)(0x026d01da475ff113)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x030c058f480f252e)),
	.hi = ((u64)(0x03e19c9072331b53)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x68d66ad906728425)),
	.hi = ((u64)(0x031ae3a6c1c27c42)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8711ef14052869b7)),
	.hi = ((u64)(0x027be952349b969b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0b4fe4ecd50d75f2)),
	.hi = ((u64)(0x03f97550542c242c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa2a650bd773df7f5)),
	.hi = ((u64)(0x032df7737689b689)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb551da312c31932a)),
	.hi = ((u64)(0x028b2c5c5ed49207)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5ddb14f4235adc22)),
	.hi = ((u64)(0x0208f049e576db39)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2fc4ee536bc49369)),
	.hi = ((u64)(0x034180763bf15ec2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbfd0bea92303a921)),
	.hi = ((u64)(0x029acd2b63277f01)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9973cbba8269541a)),
	.hi = ((u64)(0x021570ef8285ff34)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5bec792a6a42202a)),
	.hi = ((u64)(0x0355817f373ccb87)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe3239421ee9b4cef)),
	.hi = ((u64)(0x02aacdff5f63d605)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb5b6101b25490a59)),
	.hi = ((u64)(0x02223e65e5e97804)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x22bce691d541aa27)),
	.hi = ((u64)(0x0369fd6fd64259a1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb563eba7ddce21b9)),
	.hi = ((u64)(0x02bb31264501e14d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf78322ecb171b494)),
	.hi = ((u64)(0x022f5a850401810a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x259e9e47824f8753)),
	.hi = ((u64)(0x037ef73b399c01ab)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1e187e9f9b72d2a9)),
	.hi = ((u64)(0x02cbf8fc2e1667bc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4b46cbb2e2c24221)),
	.hi = ((u64)(0x023cc73024deb963)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x120adf849e039d01)),
	.hi = ((u64)(0x039471e6a1645bd2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdb3be603b19c7d9a)),
	.hi = ((u64)(0x02dd27ebb4504974)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7c2feb3627b0647c)),
	.hi = ((u64)(0x024a865629d9d45d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2d197856a5e7072c)),
	.hi = ((u64)(0x03aa7089dc8fba2f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8a7ac6abb7ec05bd)),
	.hi = ((u64)(0x02eec06e4a0c94f2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd52f05562cbcd164)),
	.hi = ((u64)(0x025899f1d4d6dd8e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x21e4d556adfae8a0)),
	.hi = ((u64)(0x03c0f64fbaf1627e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe7ea444557fbed4d)),
	.hi = ((u64)(0x0300c50c958de864)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xecbb69d1132ff10a)),
	.hi = ((u64)(0x0267040a113e5383)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xadf8a94e851981aa)),
	.hi = ((u64)(0x03d8067681fd526c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8b2d543ed0e13488)),
	.hi = ((u64)(0x0313385ece6441f0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd5bddcff0d80f6d3)),
	.hi = ((u64)(0x0275c6b23eb69b26)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x892fc7fe7c018aeb)),
	.hi = ((u64)(0x03efa45064575ea4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3a8c9ffec99ad589)),
	.hi = ((u64)(0x03261d0d1d12b21d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc8707fff07af113b)),
	.hi = ((u64)(0x0284e40a7da88e7d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x39f39998d2f2742f)),
	.hi = ((u64)(0x0203e9a1fe2071fe)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8fec28f484b7204b)),
	.hi = ((u64)(0x033975cffd00b663)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd989ba5d36f8e6a2)),
	.hi = ((u64)(0x02945e3ffd9a2b82)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x47a161e42bfa521c)),
	.hi = ((u64)(0x02104b66647b5602)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0c35696d132a1cf9)),
	.hi = ((u64)(0x034d4570a0c5566a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x09c454574288172d)),
	.hi = ((u64)(0x02a4378d4d6aab88)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa169dd129ba0128b)),
	.hi = ((u64)(0x021cf93dd7888939)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0242fb50f9001dab)),
	.hi = ((u64)(0x03618ec958da7529)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9b68c90d940017bc)),
	.hi = ((u64)(0x02b4723aad7b90ed)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4920a0d7a999ac96)),
	.hi = ((u64)(0x0229f4fbbdfc73f1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x750101590f5c4757)),
	.hi = ((u64)(0x037654c5fcc71fe8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2a6734473f7d05df)),
	.hi = ((u64)(0x02c5109e63d27fed)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xeeb8f69f65fd9e4c)),
	.hi = ((u64)(0x0237407eb641fff0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe45b24323cc8fd46)),
	.hi = ((u64)(0x038b9a6456cfffe7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb6af502830a0ca9f)),
	.hi = ((u64)(0x02d6151d123fffec)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf88c402026e7087f)),
	.hi = ((u64)(0x0244ddb0db666656)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2746cd003e3e73fe)),
	.hi = ((u64)(0x03a162b4923d708b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1f6bd73364fec332)),
	.hi = ((u64)(0x02e7822a0e978d3c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe5efdf5c50cbcf5b)),
	.hi = ((u64)(0x0252ce880bac70fc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3cb2fefa1adfb22b)),
	.hi = ((u64)(0x03b7b0d9ac471b2e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x308f3261af195b56)),
	.hi = ((u64)(0x02f95a47bd05af58)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5a0c284e25ade2ab)),
	.hi = ((u64)(0x0261150630d15913)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x29ad0d49d5e30445)),
	.hi = ((u64)(0x03ce8809e7b55b52)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x548a7107de4f369d)),
	.hi = ((u64)(0x030ba007ec9115db)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdd3b8d9fe50c2bb1)),
	.hi = ((u64)(0x026fb3398a0dab15)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x952c15cca1ad12b5)),
	.hi = ((u64)(0x03e5eb8f434911bc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x775677d6e7bda891)),
	.hi = ((u64)(0x031e560c35d40e30)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc5dec645863153a7)),
	.hi = ((u64)(0x027eab3cf7dcd826)),
}, 
});
	_const_hash__wyhash__wyp0 = ((u64)(0xa0761d6478bd642f));
	_const_hash__wyhash__wyp1 = ((u64)(0xe7037ed1a0b428db));
	_const_hash__wyhash__wyp2 = ((u64)(0x8ebc6af09c88c6e3));
	_const_hash__wyhash__wyp3 = ((u64)(0x589965cc75374cc3));
	_const_hash__wyhash__wyp4 = ((u64)(0x1d8e4e27c47d124f));
	_const_strconv__DOUBLE_PLUS_ZERO = ((u64)(0x0000000000000000));
	_const_strconv__DOUBLE_MINUS_ZERO = ((u64)(0x8000000000000000));
	_const_strconv__DOUBLE_PLUS_INFINITY = ((u64)(0x7FF0000000000000));
	_const_strconv__DOUBLE_MINUS_INFINITY = ((u64)(0xFFF0000000000000));
	_const_strconv__TEN = ((u32)(10));
	_const_strconv__max_u64 = ((u64)(UINT64_MAX));
	_const_time__month_days = new_array_from_c_array(12, 12, sizeof(int), (int[12]){
		31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 
});
	_const_time__absolute_zero_year = ((i64)(-292277022399));
	_const_time__seconds_per_hour = 60 * _const_time__seconds_per_minute;
	_const_time__seconds_per_day = 24 * _const_time__seconds_per_hour;
	_const_time__seconds_per_week = 7 * _const_time__seconds_per_day;
	_const_time__days_per_400_years = 365 * 400 + 97;
	_const_time__days_per_100_years = 365 * 100 + 24;
	_const_time__days_per_4_years = 365 * 4 + 1;
	_const_time__days_before = new_array_from_c_array(13, 13, sizeof(int), (int[13]){
		0, 31, 31 + 28, 31 + 28 + 31, 31 + 28 + 31 + 30, 31 + 28 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31, 
});
	_const_math__bits__de_bruijn32 = ((u32)(0x077CB531));
	_const_math__bits__de_bruijn32tab = new_array_from_c_array(32, 32, sizeof(byte), (byte[32]){
		((byte)(0)), 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9, 
});
	_const_math__bits__de_bruijn64 = ((u64)(0x03f79d71b4ca8b09));
	_const_math__bits__de_bruijn64tab = new_array_from_c_array(64, 64, sizeof(byte), (byte[64]){
		((byte)(0)), 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4, 62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5, 63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11, 54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6, 
});
	_const_math__bits__m0 = ((u64)(0x5555555555555555));
	_const_math__bits__m1 = ((u64)(0x3333333333333333));
	_const_math__bits__m2 = ((u64)(0x0f0f0f0f0f0f0f0f));
	_const_math__bits__m3 = ((u64)(0x00ff00ff00ff00ff));
	_const_math__bits__m4 = ((u64)(0x0000ffff0000ffff));
	_const_math__bits__max_u32 = ((u32)(4294967295));
	_const_math__bits__max_u64 = ((u64)(18446744073709551615));
	_const_math__bits__two32 = ((u64)(0x100000000));
	_const_math__bits__mask32 = _const_math__bits__two32 - 1;
	_const_math__bits__ntz_8_tab = new_array_from_c_array(256, 256, sizeof(byte), (byte[256]){
		((byte)(0x08)), 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x07, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
});
	_const_math__bits__pop_8_tab = new_array_from_c_array(256, 256, sizeof(byte), (byte[256]){
		((byte)(0x00)), 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08, 
});
	_const_math__bits__rev_8_tab = new_array_from_c_array(256, 256, sizeof(byte), (byte[256]){
		((byte)(0x00)), 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff, 
});
	_const_math__bits__len_8_tab = new_array_from_c_array(256, 256, sizeof(byte), (byte[256]){
		((byte)(0x00)), 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
});

}

